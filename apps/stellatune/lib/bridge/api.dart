// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'third_party/stellatune_core.dart';

// These functions are ignored because they are not marked as `pub`: `init_tracing`, `new`, `new`

Future<Player> createPlayer() =>
    StellatuneApi.instance.api.crateApiCreatePlayer();

Future<void> load({required Player player, required String path}) =>
    StellatuneApi.instance.api.crateApiLoad(player: player, path: path);

Future<void> play({required Player player}) =>
    StellatuneApi.instance.api.crateApiPlay(player: player);

Future<void> pause({required Player player}) =>
    StellatuneApi.instance.api.crateApiPause(player: player);

Future<void> seekMs({required Player player, required BigInt positionMs}) =>
    StellatuneApi.instance.api.crateApiSeekMs(
      player: player,
      positionMs: positionMs,
    );

Future<void> setVolume({required Player player, required double volume}) =>
    StellatuneApi.instance.api.crateApiSetVolume(
      player: player,
      volume: volume,
    );

Future<void> stop({required Player player}) =>
    StellatuneApi.instance.api.crateApiStop(player: player);

Stream<Event> events({required Player player}) =>
    StellatuneApi.instance.api.crateApiEvents(player: player);

Future<List<PluginDescriptor>> pluginsList({required Player player}) =>
    StellatuneApi.instance.api.crateApiPluginsList(player: player);

Future<List<DspTypeDescriptor>> dspListTypes({required Player player}) =>
    StellatuneApi.instance.api.crateApiDspListTypes(player: player);

Future<void> dspSetChain({
  required Player player,
  required List<DspChainItem> chain,
}) => StellatuneApi.instance.api.crateApiDspSetChain(
  player: player,
  chain: chain,
);

Future<TrackDecodeInfo?> currentTrackInfo({required Player player}) =>
    StellatuneApi.instance.api.crateApiCurrentTrackInfo(player: player);

Future<void> pluginsReload({required Player player, required String dir}) =>
    StellatuneApi.instance.api.crateApiPluginsReload(player: player, dir: dir);

Future<void> pluginsReloadWithDisabled({
  required Player player,
  required String dir,
  required List<String> disabledIds,
}) => StellatuneApi.instance.api.crateApiPluginsReloadWithDisabled(
  player: player,
  dir: dir,
  disabledIds: disabledIds,
);

Future<Library> createLibrary({
  required String dbPath,
  required List<String> disabledPluginIds,
}) => StellatuneApi.instance.api.crateApiCreateLibrary(
  dbPath: dbPath,
  disabledPluginIds: disabledPluginIds,
);

Future<void> libraryAddRoot({
  required Library library_,
  required String path,
}) => StellatuneApi.instance.api.crateApiLibraryAddRoot(
  library_: library_,
  path: path,
);

Future<void> libraryRemoveRoot({
  required Library library_,
  required String path,
}) => StellatuneApi.instance.api.crateApiLibraryRemoveRoot(
  library_: library_,
  path: path,
);

Future<void> libraryDeleteFolder({
  required Library library_,
  required String path,
}) => StellatuneApi.instance.api.crateApiLibraryDeleteFolder(
  library_: library_,
  path: path,
);

Future<void> libraryRestoreFolder({
  required Library library_,
  required String path,
}) => StellatuneApi.instance.api.crateApiLibraryRestoreFolder(
  library_: library_,
  path: path,
);

Future<void> libraryListExcludedFolders({required Library library_}) =>
    StellatuneApi.instance.api.crateApiLibraryListExcludedFolders(
      library_: library_,
    );

Future<void> libraryScanAll({required Library library_}) =>
    StellatuneApi.instance.api.crateApiLibraryScanAll(library_: library_);

Future<void> libraryScanAllForce({required Library library_}) =>
    StellatuneApi.instance.api.crateApiLibraryScanAllForce(library_: library_);

Future<void> libraryListRoots({required Library library_}) =>
    StellatuneApi.instance.api.crateApiLibraryListRoots(library_: library_);

Future<void> libraryListFolders({required Library library_}) =>
    StellatuneApi.instance.api.crateApiLibraryListFolders(library_: library_);

Future<void> libraryListTracks({
  required Library library_,
  required String folder,
  required bool recursive,
  required String query,
  required PlatformInt64 limit,
  required PlatformInt64 offset,
}) => StellatuneApi.instance.api.crateApiLibraryListTracks(
  library_: library_,
  folder: folder,
  recursive: recursive,
  query: query,
  limit: limit,
  offset: offset,
);

Future<void> librarySearch({
  required Library library_,
  required String query,
  required PlatformInt64 limit,
  required PlatformInt64 offset,
}) => StellatuneApi.instance.api.crateApiLibrarySearch(
  library_: library_,
  query: query,
  limit: limit,
  offset: offset,
);

Stream<LibraryEvent> libraryEvents({required Library library_}) =>
    StellatuneApi.instance.api.crateApiLibraryEvents(library_: library_);

Future<void> libraryPluginsReloadWithDisabled({
  required Library library_,
  required String dir,
  required List<String> disabledIds,
}) => StellatuneApi.instance.api.crateApiLibraryPluginsReloadWithDisabled(
  library_: library_,
  dir: dir,
  disabledIds: disabledIds,
);

Future<List<DlnaSsdpDevice>> dlnaDiscoverMediaRenderers({
  required int timeoutMs,
}) => StellatuneApi.instance.api.crateApiDlnaDiscoverMediaRenderers(
  timeoutMs: timeoutMs,
);

Future<List<DlnaRenderer>> dlnaDiscoverRenderers({required int timeoutMs}) =>
    StellatuneApi.instance.api.crateApiDlnaDiscoverRenderers(
      timeoutMs: timeoutMs,
    );

Future<DlnaHttpServerInfo> dlnaHttpStart({String? advertiseIp, int? port}) =>
    StellatuneApi.instance.api.crateApiDlnaHttpStart(
      advertiseIp: advertiseIp,
      port: port,
    );

Future<String> dlnaHttpPublishTrack({required String path}) =>
    StellatuneApi.instance.api.crateApiDlnaHttpPublishTrack(path: path);

Future<void> dlnaHttpUnpublishAll() =>
    StellatuneApi.instance.api.crateApiDlnaHttpUnpublishAll();

Future<void> dlnaAvTransportSetUri({
  required String controlUrl,
  String? serviceType,
  required String uri,
  String? metadata,
}) => StellatuneApi.instance.api.crateApiDlnaAvTransportSetUri(
  controlUrl: controlUrl,
  serviceType: serviceType,
  uri: uri,
  metadata: metadata,
);

Future<void> dlnaAvTransportPlay({
  required String controlUrl,
  String? serviceType,
}) => StellatuneApi.instance.api.crateApiDlnaAvTransportPlay(
  controlUrl: controlUrl,
  serviceType: serviceType,
);

Future<void> dlnaAvTransportPause({
  required String controlUrl,
  String? serviceType,
}) => StellatuneApi.instance.api.crateApiDlnaAvTransportPause(
  controlUrl: controlUrl,
  serviceType: serviceType,
);

Future<void> dlnaAvTransportStop({
  required String controlUrl,
  String? serviceType,
}) => StellatuneApi.instance.api.crateApiDlnaAvTransportStop(
  controlUrl: controlUrl,
  serviceType: serviceType,
);

Future<void> dlnaAvTransportSeekMs({
  required String controlUrl,
  String? serviceType,
  required BigInt positionMs,
}) => StellatuneApi.instance.api.crateApiDlnaAvTransportSeekMs(
  controlUrl: controlUrl,
  serviceType: serviceType,
  positionMs: positionMs,
);

Future<DlnaTransportInfo> dlnaAvTransportGetTransportInfo({
  required String controlUrl,
  String? serviceType,
}) => StellatuneApi.instance.api.crateApiDlnaAvTransportGetTransportInfo(
  controlUrl: controlUrl,
  serviceType: serviceType,
);

Future<DlnaPositionInfo> dlnaAvTransportGetPositionInfo({
  required String controlUrl,
  String? serviceType,
}) => StellatuneApi.instance.api.crateApiDlnaAvTransportGetPositionInfo(
  controlUrl: controlUrl,
  serviceType: serviceType,
);

Future<void> dlnaRenderingControlSetVolume({
  required String controlUrl,
  String? serviceType,
  required int volume0100,
}) => StellatuneApi.instance.api.crateApiDlnaRenderingControlSetVolume(
  controlUrl: controlUrl,
  serviceType: serviceType,
  volume0100: volume0100,
);

Future<void> dlnaRenderingControlSetMute({
  required String controlUrl,
  String? serviceType,
  required bool mute,
}) => StellatuneApi.instance.api.crateApiDlnaRenderingControlSetMute(
  controlUrl: controlUrl,
  serviceType: serviceType,
  mute: mute,
);

Future<int> dlnaRenderingControlGetVolume({
  required String controlUrl,
  String? serviceType,
}) => StellatuneApi.instance.api.crateApiDlnaRenderingControlGetVolume(
  controlUrl: controlUrl,
  serviceType: serviceType,
);

Future<String> dlnaPlayLocalPath({
  required DlnaRenderer renderer,
  required String path,
}) => StellatuneApi.instance.api.crateApiDlnaPlayLocalPath(
  renderer: renderer,
  path: path,
);

Future<String> dlnaPlayLocalTrack({
  required DlnaRenderer renderer,
  required String path,
  String? title,
  String? artist,
  String? album,
  String? coverPath,
}) => StellatuneApi.instance.api.crateApiDlnaPlayLocalTrack(
  renderer: renderer,
  path: path,
  title: title,
  artist: artist,
  album: album,
  coverPath: coverPath,
);

// Rust type: RustOpaqueMoi<Library>
abstract class Library implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<Player>
abstract class Player implements RustOpaqueInterface {}
