// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/dlna.dart';
import 'api/dlna/types.dart';
import 'api/library.dart';
import 'api/player.dart';
import 'api/player/types.dart';
import 'api/runtime.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'third_party/stellatune_backend_api/lyrics_types.dart';
import 'third_party/stellatune_library.dart';

/// Main entrypoint of the Rust API
class StellatuneApi
    extends
        BaseEntrypoint<
          StellatuneApiApi,
          StellatuneApiApiImpl,
          StellatuneApiWire
        > {
  @internal
  static final instance = StellatuneApi._();

  StellatuneApi._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    StellatuneApiApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required StellatuneApiApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<StellatuneApiApiImpl, StellatuneApiWire>
  get apiImplConstructor => StellatuneApiApiImpl.new;

  @override
  WireConstructor<StellatuneApiWire> get wireConstructor =>
      StellatuneApiWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 2035416143;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'stellatune_ffi',
        ioDirectory: '../../crates/stellatune-ffi/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class StellatuneApiApi extends BaseApi {
  Future<void> crateApiPlayerClearOutputSinkRoute();

  Future<void> crateApiLibraryCreateLibrary({required String dbPath});

  Future<TrackDecodeInfo?> crateApiPlayerCurrentTrackInfo();

  Future<List<String>> crateApiPlayerDecoderSupportedExtensions();

  Future<DlnaPositionInfo> crateApiDlnaDlnaAvTransportGetPositionInfo({
    required String controlUrl,
    String? serviceType,
  });

  Future<DlnaTransportInfo> crateApiDlnaDlnaAvTransportGetTransportInfo({
    required String controlUrl,
    String? serviceType,
  });

  Future<void> crateApiDlnaDlnaAvTransportPause({
    required String controlUrl,
    String? serviceType,
  });

  Future<void> crateApiDlnaDlnaAvTransportPlay({
    required String controlUrl,
    String? serviceType,
  });

  Future<void> crateApiDlnaDlnaAvTransportSeekMs({
    required String controlUrl,
    String? serviceType,
    required BigInt positionMs,
  });

  Future<void> crateApiDlnaDlnaAvTransportSetUri({
    required String controlUrl,
    String? serviceType,
    required String uri,
    String? metadata,
  });

  Future<void> crateApiDlnaDlnaAvTransportStop({
    required String controlUrl,
    String? serviceType,
  });

  Future<List<DlnaSsdpDevice>> crateApiDlnaDlnaDiscoverMediaRenderers({
    required int timeoutMs,
  });

  Future<List<DlnaRenderer>> crateApiDlnaDlnaDiscoverRenderers({
    required int timeoutMs,
  });

  Future<String> crateApiDlnaDlnaHttpPublishTrack({required String path});

  Future<DlnaHttpServerInfo> crateApiDlnaDlnaHttpStart({
    String? advertiseIp,
    int? port,
  });

  Future<void> crateApiDlnaDlnaHttpUnpublishAll();

  Future<String> crateApiDlnaDlnaPlayLocalPath({
    required DlnaRenderer renderer,
    required String path,
  });

  Future<String> crateApiDlnaDlnaPlayLocalTrack({
    required DlnaRenderer renderer,
    required String path,
    String? title,
    String? artist,
    String? album,
    String? coverPath,
  });

  Future<int> crateApiDlnaDlnaRenderingControlGetVolume({
    required String controlUrl,
    String? serviceType,
  });

  Future<void> crateApiDlnaDlnaRenderingControlSetMute({
    required String controlUrl,
    String? serviceType,
    required bool mute,
  });

  Future<void> crateApiDlnaDlnaRenderingControlSetVolume({
    required String controlUrl,
    String? serviceType,
    required int volume0100,
  });

  Future<List<DspTypeDescriptor>> crateApiPlayerDspListTypes();

  Future<void> crateApiPlayerDspSetChain({required List<DspChainItem> chain});

  Stream<Event> crateApiPlayerEvents();

  Future<void> crateApiInitApp();

  Future<LfeMode> crateApiPlayerTypesLfeModeDefault();

  Future<void> crateApiLibraryLibraryAddRoot({required String path});

  Future<void> crateApiLibraryLibraryAddTrackToPlaylist({
    required PlatformInt64 playlistId,
    required PlatformInt64 trackId,
  });

  Future<void> crateApiLibraryLibraryAddTracksToPlaylist({
    required PlatformInt64 playlistId,
    required Int64List trackIds,
  });

  Future<void> crateApiLibraryLibraryCreatePlaylist({required String name});

  Future<void> crateApiLibraryLibraryDeleteFolder({required String path});

  Future<void> crateApiLibraryLibraryDeletePlaylist({
    required PlatformInt64 id,
  });

  Stream<LibraryEvent> crateApiLibraryLibraryEvents();

  Future<List<String>> crateApiLibraryLibraryListDisabledPluginIds();

  Future<List<String>> crateApiLibraryLibraryListExcludedFolders();

  Future<List<String>> crateApiLibraryLibraryListFolders();

  Future<Int64List> crateApiLibraryLibraryListLikedTrackIds();

  Future<List<TrackLite>> crateApiLibraryLibraryListPlaylistTracks({
    required PlatformInt64 playlistId,
    required String query,
    required PlatformInt64 limit,
    required PlatformInt64 offset,
  });

  Future<List<PlaylistLite>> crateApiLibraryLibraryListPlaylists();

  Future<List<String>> crateApiLibraryLibraryListRoots();

  Future<List<TrackLite>> crateApiLibraryLibraryListTracks({
    required String folder,
    required bool recursive,
    required String query,
    required PlatformInt64 limit,
    required PlatformInt64 offset,
  });

  Future<void> crateApiLibraryLibraryMoveTrackInPlaylist({
    required PlatformInt64 playlistId,
    required PlatformInt64 trackId,
    required PlatformInt64 newIndex,
  });

  Future<void> crateApiLibraryLibraryPluginApplyState();

  Future<String> crateApiLibraryLibraryPluginApplyStateStatusJson();

  Future<void> crateApiLibraryLibraryPluginDisable({required String pluginId});

  Future<void> crateApiLibraryLibraryPluginEnable({required String pluginId});

  Future<void> crateApiLibraryLibraryRemoveRoot({required String path});

  Future<void> crateApiLibraryLibraryRemoveTrackFromPlaylist({
    required PlatformInt64 playlistId,
    required PlatformInt64 trackId,
  });

  Future<void> crateApiLibraryLibraryRemoveTracksFromPlaylist({
    required PlatformInt64 playlistId,
    required Int64List trackIds,
  });

  Future<void> crateApiLibraryLibraryRenamePlaylist({
    required PlatformInt64 id,
    required String name,
  });

  Future<void> crateApiLibraryLibraryRestoreFolder({required String path});

  Future<void> crateApiLibraryLibraryScanAll();

  Future<void> crateApiLibraryLibraryScanAllForce();

  Future<List<TrackLite>> crateApiLibraryLibrarySearch({
    required String query,
    required PlatformInt64 limit,
    required PlatformInt64 offset,
  });

  Future<void> crateApiLibraryLibrarySetTrackLiked({
    required PlatformInt64 trackId,
    required bool liked,
  });

  Future<void> crateApiPlayerLyricsApplyCandidate({
    required String trackKey,
    required LyricsDoc doc,
  });

  Future<void> crateApiPlayerLyricsClearCache();

  Stream<LyricsEvent> crateApiPlayerLyricsEvents();

  Future<void> crateApiPlayerLyricsPrefetch({required LyricsQuery query});

  Future<void> crateApiPlayerLyricsPrepare({required LyricsQuery query});

  Future<String> crateApiPlayerLyricsProviderFetchJson({
    required String pluginId,
    required String typeId,
    required String trackJson,
  });

  Future<List<LyricsProviderTypeDescriptor>>
  crateApiPlayerLyricsProviderListTypes();

  Future<String> crateApiPlayerLyricsProviderSearchJson({
    required String pluginId,
    required String typeId,
    required String queryJson,
  });

  Future<void> crateApiPlayerLyricsRefreshCurrent();

  Future<List<LyricsSearchCandidate>> crateApiPlayerLyricsSearchCandidates({
    required LyricsQuery query,
  });

  Future<void> crateApiPlayerLyricsSetCacheDbPath({required String dbPath});

  Future<void> crateApiPlayerLyricsSetPositionMs({required BigInt positionMs});

  Future<String> crateApiPlayerOutputSinkListTargetsJson({
    required String pluginId,
    required String typeId,
    required String configJson,
  });

  Future<List<OutputSinkTypeDescriptor>> crateApiPlayerOutputSinkListTypes();

  Future<void> crateApiPlayerPause();

  Future<void> crateApiPlayerPlay();

  Future<void> crateApiPlayerPluginPublishEventJson({
    String? pluginId,
    required String eventJson,
  });

  Stream<PluginRuntimeEvent> crateApiPlayerPluginRuntimeEventsGlobal();

  Future<String> crateApiPlayerPluginsInstallFromFile({
    required String pluginsDir,
    required String artifactPath,
  });

  Future<List<PluginDescriptor>> crateApiPlayerPluginsList();

  Future<String> crateApiPlayerPluginsListInstalledJson({
    required String pluginsDir,
  });

  Future<void> crateApiPlayerPluginsUninstallById({
    required String pluginsDir,
    required String pluginId,
  });

  Future<void> crateApiPlayerPreloadTrack({
    required String path,
    required BigInt positionMs,
  });

  Future<void> crateApiPlayerPreloadTrackRef({
    required TrackRef track,
    required BigInt positionMs,
  });

  Future<List<AudioDevice>> crateApiPlayerRefreshDevices();

  Future<ResampleQuality> crateApiPlayerTypesResampleQualityDefault();

  Future<void> crateApiPlayerSeekMs({required BigInt positionMs});

  Future<void> crateApiPlayerSetLfeMode({required LfeMode mode});

  Future<void> crateApiPlayerSetOutputDevice({
    required AudioBackend backend,
    String? deviceId,
  });

  Future<void> crateApiPlayerSetOutputOptions({
    required bool matchTrackSampleRate,
    required bool gaplessPlayback,
    required bool seekTrackFade,
    required ResampleQuality resampleQuality,
  });

  Future<void> crateApiPlayerSetOutputSinkRoute({
    required OutputSinkRoute route,
  });

  Future<void> crateApiPlayerSetVolume({
    required double volume,
    required BigInt seq,
    required int rampMs,
  });

  Future<void> crateApiRuntimeShutdown();

  Future<String> crateApiPlayerSourceListItemsJson({
    required String pluginId,
    required String typeId,
    required String configJson,
    required String requestJson,
  });

  Future<List<SourceCatalogTypeDescriptor>> crateApiPlayerSourceListTypes();

  Future<void> crateApiPlayerStop();

  Future<void> crateApiPlayerSwitchTrackRef({
    required TrackRef track,
    required bool lazy,
  });

  Future<TrackRef> crateApiPlayerTypesTrackRefForLocalPath({
    required String path,
  });

  Future<TrackRef> crateApiPlayerTypesTrackRefNew({
    required String sourceId,
    required String trackId,
    required String locator,
  });

  Future<String> crateApiPlayerTypesTrackRefStableKey({required TrackRef that});
}

class StellatuneApiApiImpl extends StellatuneApiApiImplPlatform
    implements StellatuneApiApi {
  StellatuneApiApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiPlayerClearOutputSinkRoute() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 1,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerClearOutputSinkRouteConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerClearOutputSinkRouteConstMeta =>
      const TaskConstMeta(debugName: "clear_output_sink_route", argNames: []);

  @override
  Future<void> crateApiLibraryCreateLibrary({required String dbPath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(dbPath, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 2,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryCreateLibraryConstMeta,
        argValues: [dbPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryCreateLibraryConstMeta =>
      const TaskConstMeta(debugName: "create_library", argNames: ["dbPath"]);

  @override
  Future<TrackDecodeInfo?> crateApiPlayerCurrentTrackInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 3,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_track_decode_info,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerCurrentTrackInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerCurrentTrackInfoConstMeta =>
      const TaskConstMeta(debugName: "current_track_info", argNames: []);

  @override
  Future<List<String>> crateApiPlayerDecoderSupportedExtensions() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 4,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerDecoderSupportedExtensionsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerDecoderSupportedExtensionsConstMeta =>
      const TaskConstMeta(
        debugName: "decoder_supported_extensions",
        argNames: [],
      );

  @override
  Future<DlnaPositionInfo> crateApiDlnaDlnaAvTransportGetPositionInfo({
    required String controlUrl,
    String? serviceType,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(controlUrl, serializer);
          sse_encode_opt_String(serviceType, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 5,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_dlna_position_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaAvTransportGetPositionInfoConstMeta,
        argValues: [controlUrl, serviceType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaAvTransportGetPositionInfoConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_av_transport_get_position_info",
        argNames: ["controlUrl", "serviceType"],
      );

  @override
  Future<DlnaTransportInfo> crateApiDlnaDlnaAvTransportGetTransportInfo({
    required String controlUrl,
    String? serviceType,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(controlUrl, serializer);
          sse_encode_opt_String(serviceType, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 6,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_dlna_transport_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaAvTransportGetTransportInfoConstMeta,
        argValues: [controlUrl, serviceType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaAvTransportGetTransportInfoConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_av_transport_get_transport_info",
        argNames: ["controlUrl", "serviceType"],
      );

  @override
  Future<void> crateApiDlnaDlnaAvTransportPause({
    required String controlUrl,
    String? serviceType,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(controlUrl, serializer);
          sse_encode_opt_String(serviceType, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 7,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaAvTransportPauseConstMeta,
        argValues: [controlUrl, serviceType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaAvTransportPauseConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_av_transport_pause",
        argNames: ["controlUrl", "serviceType"],
      );

  @override
  Future<void> crateApiDlnaDlnaAvTransportPlay({
    required String controlUrl,
    String? serviceType,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(controlUrl, serializer);
          sse_encode_opt_String(serviceType, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 8,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaAvTransportPlayConstMeta,
        argValues: [controlUrl, serviceType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaAvTransportPlayConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_av_transport_play",
        argNames: ["controlUrl", "serviceType"],
      );

  @override
  Future<void> crateApiDlnaDlnaAvTransportSeekMs({
    required String controlUrl,
    String? serviceType,
    required BigInt positionMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(controlUrl, serializer);
          sse_encode_opt_String(serviceType, serializer);
          sse_encode_u_64(positionMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 9,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaAvTransportSeekMsConstMeta,
        argValues: [controlUrl, serviceType, positionMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaAvTransportSeekMsConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_av_transport_seek_ms",
        argNames: ["controlUrl", "serviceType", "positionMs"],
      );

  @override
  Future<void> crateApiDlnaDlnaAvTransportSetUri({
    required String controlUrl,
    String? serviceType,
    required String uri,
    String? metadata,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(controlUrl, serializer);
          sse_encode_opt_String(serviceType, serializer);
          sse_encode_String(uri, serializer);
          sse_encode_opt_String(metadata, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 10,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaAvTransportSetUriConstMeta,
        argValues: [controlUrl, serviceType, uri, metadata],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaAvTransportSetUriConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_av_transport_set_uri",
        argNames: ["controlUrl", "serviceType", "uri", "metadata"],
      );

  @override
  Future<void> crateApiDlnaDlnaAvTransportStop({
    required String controlUrl,
    String? serviceType,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(controlUrl, serializer);
          sse_encode_opt_String(serviceType, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 11,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaAvTransportStopConstMeta,
        argValues: [controlUrl, serviceType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaAvTransportStopConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_av_transport_stop",
        argNames: ["controlUrl", "serviceType"],
      );

  @override
  Future<List<DlnaSsdpDevice>> crateApiDlnaDlnaDiscoverMediaRenderers({
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_32(timeoutMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 12,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_dlna_ssdp_device,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaDiscoverMediaRenderersConstMeta,
        argValues: [timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaDiscoverMediaRenderersConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_discover_media_renderers",
        argNames: ["timeoutMs"],
      );

  @override
  Future<List<DlnaRenderer>> crateApiDlnaDlnaDiscoverRenderers({
    required int timeoutMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_32(timeoutMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 13,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_dlna_renderer,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaDiscoverRenderersConstMeta,
        argValues: [timeoutMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaDiscoverRenderersConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_discover_renderers",
        argNames: ["timeoutMs"],
      );

  @override
  Future<String> crateApiDlnaDlnaHttpPublishTrack({required String path}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 14,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaHttpPublishTrackConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaHttpPublishTrackConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_http_publish_track",
        argNames: ["path"],
      );

  @override
  Future<DlnaHttpServerInfo> crateApiDlnaDlnaHttpStart({
    String? advertiseIp,
    int? port,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_opt_String(advertiseIp, serializer);
          sse_encode_opt_box_autoadd_u_16(port, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 15,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_dlna_http_server_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaHttpStartConstMeta,
        argValues: [advertiseIp, port],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaHttpStartConstMeta => const TaskConstMeta(
    debugName: "dlna_http_start",
    argNames: ["advertiseIp", "port"],
  );

  @override
  Future<void> crateApiDlnaDlnaHttpUnpublishAll() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 16,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaHttpUnpublishAllConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaHttpUnpublishAllConstMeta =>
      const TaskConstMeta(debugName: "dlna_http_unpublish_all", argNames: []);

  @override
  Future<String> crateApiDlnaDlnaPlayLocalPath({
    required DlnaRenderer renderer,
    required String path,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_dlna_renderer(renderer, serializer);
          sse_encode_String(path, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 17,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaPlayLocalPathConstMeta,
        argValues: [renderer, path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaPlayLocalPathConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_play_local_path",
        argNames: ["renderer", "path"],
      );

  @override
  Future<String> crateApiDlnaDlnaPlayLocalTrack({
    required DlnaRenderer renderer,
    required String path,
    String? title,
    String? artist,
    String? album,
    String? coverPath,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_dlna_renderer(renderer, serializer);
          sse_encode_String(path, serializer);
          sse_encode_opt_String(title, serializer);
          sse_encode_opt_String(artist, serializer);
          sse_encode_opt_String(album, serializer);
          sse_encode_opt_String(coverPath, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 18,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaPlayLocalTrackConstMeta,
        argValues: [renderer, path, title, artist, album, coverPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaPlayLocalTrackConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_play_local_track",
        argNames: ["renderer", "path", "title", "artist", "album", "coverPath"],
      );

  @override
  Future<int> crateApiDlnaDlnaRenderingControlGetVolume({
    required String controlUrl,
    String? serviceType,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(controlUrl, serializer);
          sse_encode_opt_String(serviceType, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 19,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_8,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaRenderingControlGetVolumeConstMeta,
        argValues: [controlUrl, serviceType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaRenderingControlGetVolumeConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_rendering_control_get_volume",
        argNames: ["controlUrl", "serviceType"],
      );

  @override
  Future<void> crateApiDlnaDlnaRenderingControlSetMute({
    required String controlUrl,
    String? serviceType,
    required bool mute,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(controlUrl, serializer);
          sse_encode_opt_String(serviceType, serializer);
          sse_encode_bool(mute, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 20,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaRenderingControlSetMuteConstMeta,
        argValues: [controlUrl, serviceType, mute],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaRenderingControlSetMuteConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_rendering_control_set_mute",
        argNames: ["controlUrl", "serviceType", "mute"],
      );

  @override
  Future<void> crateApiDlnaDlnaRenderingControlSetVolume({
    required String controlUrl,
    String? serviceType,
    required int volume0100,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(controlUrl, serializer);
          sse_encode_opt_String(serviceType, serializer);
          sse_encode_u_8(volume0100, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 21,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDlnaDlnaRenderingControlSetVolumeConstMeta,
        argValues: [controlUrl, serviceType, volume0100],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDlnaDlnaRenderingControlSetVolumeConstMeta =>
      const TaskConstMeta(
        debugName: "dlna_rendering_control_set_volume",
        argNames: ["controlUrl", "serviceType", "volume0100"],
      );

  @override
  Future<List<DspTypeDescriptor>> crateApiPlayerDspListTypes() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 22,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_dsp_type_descriptor,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerDspListTypesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerDspListTypesConstMeta =>
      const TaskConstMeta(debugName: "dsp_list_types", argNames: []);

  @override
  Future<void> crateApiPlayerDspSetChain({required List<DspChainItem> chain}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_dsp_chain_item(chain, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 23,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerDspSetChainConstMeta,
        argValues: [chain],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerDspSetChainConstMeta =>
      const TaskConstMeta(debugName: "dsp_set_chain", argNames: ["chain"]);

  @override
  Stream<Event> crateApiPlayerEvents() {
    final sink = RustStreamSink<Event>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_event_Sse(sink, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 24,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiPlayerEventsConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiPlayerEventsConstMeta =>
      const TaskConstMeta(debugName: "events", argNames: ["sink"]);

  @override
  Future<void> crateApiInitApp() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 25,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiInitAppConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitAppConstMeta =>
      const TaskConstMeta(debugName: "init_app", argNames: []);

  @override
  Future<LfeMode> crateApiPlayerTypesLfeModeDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 26,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_lfe_mode,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerTypesLfeModeDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerTypesLfeModeDefaultConstMeta =>
      const TaskConstMeta(debugName: "lfe_mode_default", argNames: []);

  @override
  Future<void> crateApiLibraryLibraryAddRoot({required String path}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 27,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryAddRootConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryAddRootConstMeta =>
      const TaskConstMeta(debugName: "library_add_root", argNames: ["path"]);

  @override
  Future<void> crateApiLibraryLibraryAddTrackToPlaylist({
    required PlatformInt64 playlistId,
    required PlatformInt64 trackId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(playlistId, serializer);
          sse_encode_i_64(trackId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 28,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryAddTrackToPlaylistConstMeta,
        argValues: [playlistId, trackId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryAddTrackToPlaylistConstMeta =>
      const TaskConstMeta(
        debugName: "library_add_track_to_playlist",
        argNames: ["playlistId", "trackId"],
      );

  @override
  Future<void> crateApiLibraryLibraryAddTracksToPlaylist({
    required PlatformInt64 playlistId,
    required Int64List trackIds,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(playlistId, serializer);
          sse_encode_list_prim_i_64_strict(trackIds, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 29,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryAddTracksToPlaylistConstMeta,
        argValues: [playlistId, trackIds],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryAddTracksToPlaylistConstMeta =>
      const TaskConstMeta(
        debugName: "library_add_tracks_to_playlist",
        argNames: ["playlistId", "trackIds"],
      );

  @override
  Future<void> crateApiLibraryLibraryCreatePlaylist({required String name}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 30,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryCreatePlaylistConstMeta,
        argValues: [name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryCreatePlaylistConstMeta =>
      const TaskConstMeta(
        debugName: "library_create_playlist",
        argNames: ["name"],
      );

  @override
  Future<void> crateApiLibraryLibraryDeleteFolder({required String path}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 31,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryDeleteFolderConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryDeleteFolderConstMeta =>
      const TaskConstMeta(
        debugName: "library_delete_folder",
        argNames: ["path"],
      );

  @override
  Future<void> crateApiLibraryLibraryDeletePlaylist({
    required PlatformInt64 id,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(id, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 32,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryDeletePlaylistConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryDeletePlaylistConstMeta =>
      const TaskConstMeta(
        debugName: "library_delete_playlist",
        argNames: ["id"],
      );

  @override
  Stream<LibraryEvent> crateApiLibraryLibraryEvents() {
    final sink = RustStreamSink<LibraryEvent>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_library_event_Sse(sink, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 33,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiLibraryLibraryEventsConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiLibraryLibraryEventsConstMeta =>
      const TaskConstMeta(debugName: "library_events", argNames: ["sink"]);

  @override
  Future<List<String>> crateApiLibraryLibraryListDisabledPluginIds() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 34,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryListDisabledPluginIdsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryListDisabledPluginIdsConstMeta =>
      const TaskConstMeta(
        debugName: "library_list_disabled_plugin_ids",
        argNames: [],
      );

  @override
  Future<List<String>> crateApiLibraryLibraryListExcludedFolders() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 35,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryListExcludedFoldersConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryListExcludedFoldersConstMeta =>
      const TaskConstMeta(
        debugName: "library_list_excluded_folders",
        argNames: [],
      );

  @override
  Future<List<String>> crateApiLibraryLibraryListFolders() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 36,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryListFoldersConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryListFoldersConstMeta =>
      const TaskConstMeta(debugName: "library_list_folders", argNames: []);

  @override
  Future<Int64List> crateApiLibraryLibraryListLikedTrackIds() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 37,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_i_64_strict,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryListLikedTrackIdsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryListLikedTrackIdsConstMeta =>
      const TaskConstMeta(
        debugName: "library_list_liked_track_ids",
        argNames: [],
      );

  @override
  Future<List<TrackLite>> crateApiLibraryLibraryListPlaylistTracks({
    required PlatformInt64 playlistId,
    required String query,
    required PlatformInt64 limit,
    required PlatformInt64 offset,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(playlistId, serializer);
          sse_encode_String(query, serializer);
          sse_encode_i_64(limit, serializer);
          sse_encode_i_64(offset, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 38,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_track_lite,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryListPlaylistTracksConstMeta,
        argValues: [playlistId, query, limit, offset],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryListPlaylistTracksConstMeta =>
      const TaskConstMeta(
        debugName: "library_list_playlist_tracks",
        argNames: ["playlistId", "query", "limit", "offset"],
      );

  @override
  Future<List<PlaylistLite>> crateApiLibraryLibraryListPlaylists() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 39,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_playlist_lite,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryListPlaylistsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryListPlaylistsConstMeta =>
      const TaskConstMeta(debugName: "library_list_playlists", argNames: []);

  @override
  Future<List<String>> crateApiLibraryLibraryListRoots() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 40,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryListRootsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryListRootsConstMeta =>
      const TaskConstMeta(debugName: "library_list_roots", argNames: []);

  @override
  Future<List<TrackLite>> crateApiLibraryLibraryListTracks({
    required String folder,
    required bool recursive,
    required String query,
    required PlatformInt64 limit,
    required PlatformInt64 offset,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(folder, serializer);
          sse_encode_bool(recursive, serializer);
          sse_encode_String(query, serializer);
          sse_encode_i_64(limit, serializer);
          sse_encode_i_64(offset, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 41,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_track_lite,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryListTracksConstMeta,
        argValues: [folder, recursive, query, limit, offset],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryListTracksConstMeta =>
      const TaskConstMeta(
        debugName: "library_list_tracks",
        argNames: ["folder", "recursive", "query", "limit", "offset"],
      );

  @override
  Future<void> crateApiLibraryLibraryMoveTrackInPlaylist({
    required PlatformInt64 playlistId,
    required PlatformInt64 trackId,
    required PlatformInt64 newIndex,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(playlistId, serializer);
          sse_encode_i_64(trackId, serializer);
          sse_encode_i_64(newIndex, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 42,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryMoveTrackInPlaylistConstMeta,
        argValues: [playlistId, trackId, newIndex],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryMoveTrackInPlaylistConstMeta =>
      const TaskConstMeta(
        debugName: "library_move_track_in_playlist",
        argNames: ["playlistId", "trackId", "newIndex"],
      );

  @override
  Future<void> crateApiLibraryLibraryPluginApplyState() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 43,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryPluginApplyStateConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryPluginApplyStateConstMeta =>
      const TaskConstMeta(
        debugName: "library_plugin_apply_state",
        argNames: [],
      );

  @override
  Future<String> crateApiLibraryLibraryPluginApplyStateStatusJson() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 44,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryPluginApplyStateStatusJsonConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiLibraryLibraryPluginApplyStateStatusJsonConstMeta =>
      const TaskConstMeta(
        debugName: "library_plugin_apply_state_status_json",
        argNames: [],
      );

  @override
  Future<void> crateApiLibraryLibraryPluginDisable({required String pluginId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pluginId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 45,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryPluginDisableConstMeta,
        argValues: [pluginId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryPluginDisableConstMeta =>
      const TaskConstMeta(
        debugName: "library_plugin_disable",
        argNames: ["pluginId"],
      );

  @override
  Future<void> crateApiLibraryLibraryPluginEnable({required String pluginId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pluginId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 46,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryPluginEnableConstMeta,
        argValues: [pluginId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryPluginEnableConstMeta =>
      const TaskConstMeta(
        debugName: "library_plugin_enable",
        argNames: ["pluginId"],
      );

  @override
  Future<void> crateApiLibraryLibraryRemoveRoot({required String path}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 47,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryRemoveRootConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryRemoveRootConstMeta =>
      const TaskConstMeta(debugName: "library_remove_root", argNames: ["path"]);

  @override
  Future<void> crateApiLibraryLibraryRemoveTrackFromPlaylist({
    required PlatformInt64 playlistId,
    required PlatformInt64 trackId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(playlistId, serializer);
          sse_encode_i_64(trackId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 48,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryRemoveTrackFromPlaylistConstMeta,
        argValues: [playlistId, trackId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryRemoveTrackFromPlaylistConstMeta =>
      const TaskConstMeta(
        debugName: "library_remove_track_from_playlist",
        argNames: ["playlistId", "trackId"],
      );

  @override
  Future<void> crateApiLibraryLibraryRemoveTracksFromPlaylist({
    required PlatformInt64 playlistId,
    required Int64List trackIds,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(playlistId, serializer);
          sse_encode_list_prim_i_64_strict(trackIds, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 49,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryRemoveTracksFromPlaylistConstMeta,
        argValues: [playlistId, trackIds],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryRemoveTracksFromPlaylistConstMeta =>
      const TaskConstMeta(
        debugName: "library_remove_tracks_from_playlist",
        argNames: ["playlistId", "trackIds"],
      );

  @override
  Future<void> crateApiLibraryLibraryRenamePlaylist({
    required PlatformInt64 id,
    required String name,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(id, serializer);
          sse_encode_String(name, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 50,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryRenamePlaylistConstMeta,
        argValues: [id, name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryRenamePlaylistConstMeta =>
      const TaskConstMeta(
        debugName: "library_rename_playlist",
        argNames: ["id", "name"],
      );

  @override
  Future<void> crateApiLibraryLibraryRestoreFolder({required String path}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 51,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryRestoreFolderConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryRestoreFolderConstMeta =>
      const TaskConstMeta(
        debugName: "library_restore_folder",
        argNames: ["path"],
      );

  @override
  Future<void> crateApiLibraryLibraryScanAll() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 52,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryScanAllConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryScanAllConstMeta =>
      const TaskConstMeta(debugName: "library_scan_all", argNames: []);

  @override
  Future<void> crateApiLibraryLibraryScanAllForce() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 53,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibraryScanAllForceConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibraryScanAllForceConstMeta =>
      const TaskConstMeta(debugName: "library_scan_all_force", argNames: []);

  @override
  Future<List<TrackLite>> crateApiLibraryLibrarySearch({
    required String query,
    required PlatformInt64 limit,
    required PlatformInt64 offset,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(query, serializer);
          sse_encode_i_64(limit, serializer);
          sse_encode_i_64(offset, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 54,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_track_lite,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibrarySearchConstMeta,
        argValues: [query, limit, offset],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibrarySearchConstMeta =>
      const TaskConstMeta(
        debugName: "library_search",
        argNames: ["query", "limit", "offset"],
      );

  @override
  Future<void> crateApiLibraryLibrarySetTrackLiked({
    required PlatformInt64 trackId,
    required bool liked,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(trackId, serializer);
          sse_encode_bool(liked, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 55,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiLibraryLibrarySetTrackLikedConstMeta,
        argValues: [trackId, liked],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiLibraryLibrarySetTrackLikedConstMeta =>
      const TaskConstMeta(
        debugName: "library_set_track_liked",
        argNames: ["trackId", "liked"],
      );

  @override
  Future<void> crateApiPlayerLyricsApplyCandidate({
    required String trackKey,
    required LyricsDoc doc,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(trackKey, serializer);
          sse_encode_box_autoadd_lyrics_doc(doc, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 56,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerLyricsApplyCandidateConstMeta,
        argValues: [trackKey, doc],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsApplyCandidateConstMeta =>
      const TaskConstMeta(
        debugName: "lyrics_apply_candidate",
        argNames: ["trackKey", "doc"],
      );

  @override
  Future<void> crateApiPlayerLyricsClearCache() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 57,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerLyricsClearCacheConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsClearCacheConstMeta =>
      const TaskConstMeta(debugName: "lyrics_clear_cache", argNames: []);

  @override
  Stream<LyricsEvent> crateApiPlayerLyricsEvents() {
    final sink = RustStreamSink<LyricsEvent>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_lyrics_event_Sse(sink, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 58,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiPlayerLyricsEventsConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiPlayerLyricsEventsConstMeta =>
      const TaskConstMeta(debugName: "lyrics_events", argNames: ["sink"]);

  @override
  Future<void> crateApiPlayerLyricsPrefetch({required LyricsQuery query}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_lyrics_query(query, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 59,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerLyricsPrefetchConstMeta,
        argValues: [query],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsPrefetchConstMeta =>
      const TaskConstMeta(debugName: "lyrics_prefetch", argNames: ["query"]);

  @override
  Future<void> crateApiPlayerLyricsPrepare({required LyricsQuery query}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_lyrics_query(query, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 60,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerLyricsPrepareConstMeta,
        argValues: [query],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsPrepareConstMeta =>
      const TaskConstMeta(debugName: "lyrics_prepare", argNames: ["query"]);

  @override
  Future<String> crateApiPlayerLyricsProviderFetchJson({
    required String pluginId,
    required String typeId,
    required String trackJson,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pluginId, serializer);
          sse_encode_String(typeId, serializer);
          sse_encode_String(trackJson, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 61,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerLyricsProviderFetchJsonConstMeta,
        argValues: [pluginId, typeId, trackJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsProviderFetchJsonConstMeta =>
      const TaskConstMeta(
        debugName: "lyrics_provider_fetch_json",
        argNames: ["pluginId", "typeId", "trackJson"],
      );

  @override
  Future<List<LyricsProviderTypeDescriptor>>
  crateApiPlayerLyricsProviderListTypes() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 62,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_lyrics_provider_type_descriptor,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerLyricsProviderListTypesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsProviderListTypesConstMeta =>
      const TaskConstMeta(
        debugName: "lyrics_provider_list_types",
        argNames: [],
      );

  @override
  Future<String> crateApiPlayerLyricsProviderSearchJson({
    required String pluginId,
    required String typeId,
    required String queryJson,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pluginId, serializer);
          sse_encode_String(typeId, serializer);
          sse_encode_String(queryJson, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 63,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerLyricsProviderSearchJsonConstMeta,
        argValues: [pluginId, typeId, queryJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsProviderSearchJsonConstMeta =>
      const TaskConstMeta(
        debugName: "lyrics_provider_search_json",
        argNames: ["pluginId", "typeId", "queryJson"],
      );

  @override
  Future<void> crateApiPlayerLyricsRefreshCurrent() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 64,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerLyricsRefreshCurrentConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsRefreshCurrentConstMeta =>
      const TaskConstMeta(debugName: "lyrics_refresh_current", argNames: []);

  @override
  Future<List<LyricsSearchCandidate>> crateApiPlayerLyricsSearchCandidates({
    required LyricsQuery query,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_lyrics_query(query, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 65,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_lyrics_search_candidate,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerLyricsSearchCandidatesConstMeta,
        argValues: [query],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsSearchCandidatesConstMeta =>
      const TaskConstMeta(
        debugName: "lyrics_search_candidates",
        argNames: ["query"],
      );

  @override
  Future<void> crateApiPlayerLyricsSetCacheDbPath({required String dbPath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(dbPath, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 66,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerLyricsSetCacheDbPathConstMeta,
        argValues: [dbPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsSetCacheDbPathConstMeta =>
      const TaskConstMeta(
        debugName: "lyrics_set_cache_db_path",
        argNames: ["dbPath"],
      );

  @override
  Future<void> crateApiPlayerLyricsSetPositionMs({required BigInt positionMs}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_64(positionMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 67,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerLyricsSetPositionMsConstMeta,
        argValues: [positionMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerLyricsSetPositionMsConstMeta =>
      const TaskConstMeta(
        debugName: "lyrics_set_position_ms",
        argNames: ["positionMs"],
      );

  @override
  Future<String> crateApiPlayerOutputSinkListTargetsJson({
    required String pluginId,
    required String typeId,
    required String configJson,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pluginId, serializer);
          sse_encode_String(typeId, serializer);
          sse_encode_String(configJson, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 68,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerOutputSinkListTargetsJsonConstMeta,
        argValues: [pluginId, typeId, configJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerOutputSinkListTargetsJsonConstMeta =>
      const TaskConstMeta(
        debugName: "output_sink_list_targets_json",
        argNames: ["pluginId", "typeId", "configJson"],
      );

  @override
  Future<List<OutputSinkTypeDescriptor>> crateApiPlayerOutputSinkListTypes() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 69,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_output_sink_type_descriptor,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerOutputSinkListTypesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerOutputSinkListTypesConstMeta =>
      const TaskConstMeta(debugName: "output_sink_list_types", argNames: []);

  @override
  Future<void> crateApiPlayerPause() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 70,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerPauseConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerPauseConstMeta =>
      const TaskConstMeta(debugName: "pause", argNames: []);

  @override
  Future<void> crateApiPlayerPlay() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 71,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerPlayConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerPlayConstMeta =>
      const TaskConstMeta(debugName: "play", argNames: []);

  @override
  Future<void> crateApiPlayerPluginPublishEventJson({
    String? pluginId,
    required String eventJson,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_opt_String(pluginId, serializer);
          sse_encode_String(eventJson, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 72,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerPluginPublishEventJsonConstMeta,
        argValues: [pluginId, eventJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerPluginPublishEventJsonConstMeta =>
      const TaskConstMeta(
        debugName: "plugin_publish_event_json",
        argNames: ["pluginId", "eventJson"],
      );

  @override
  Stream<PluginRuntimeEvent> crateApiPlayerPluginRuntimeEventsGlobal() {
    final sink = RustStreamSink<PluginRuntimeEvent>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_plugin_runtime_event_Sse(sink, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 73,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiPlayerPluginRuntimeEventsGlobalConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiPlayerPluginRuntimeEventsGlobalConstMeta =>
      const TaskConstMeta(
        debugName: "plugin_runtime_events_global",
        argNames: ["sink"],
      );

  @override
  Future<String> crateApiPlayerPluginsInstallFromFile({
    required String pluginsDir,
    required String artifactPath,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pluginsDir, serializer);
          sse_encode_String(artifactPath, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 74,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerPluginsInstallFromFileConstMeta,
        argValues: [pluginsDir, artifactPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerPluginsInstallFromFileConstMeta =>
      const TaskConstMeta(
        debugName: "plugins_install_from_file",
        argNames: ["pluginsDir", "artifactPath"],
      );

  @override
  Future<List<PluginDescriptor>> crateApiPlayerPluginsList() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 75,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_plugin_descriptor,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerPluginsListConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerPluginsListConstMeta =>
      const TaskConstMeta(debugName: "plugins_list", argNames: []);

  @override
  Future<String> crateApiPlayerPluginsListInstalledJson({
    required String pluginsDir,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pluginsDir, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 76,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerPluginsListInstalledJsonConstMeta,
        argValues: [pluginsDir],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerPluginsListInstalledJsonConstMeta =>
      const TaskConstMeta(
        debugName: "plugins_list_installed_json",
        argNames: ["pluginsDir"],
      );

  @override
  Future<void> crateApiPlayerPluginsUninstallById({
    required String pluginsDir,
    required String pluginId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pluginsDir, serializer);
          sse_encode_String(pluginId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 77,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerPluginsUninstallByIdConstMeta,
        argValues: [pluginsDir, pluginId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerPluginsUninstallByIdConstMeta =>
      const TaskConstMeta(
        debugName: "plugins_uninstall_by_id",
        argNames: ["pluginsDir", "pluginId"],
      );

  @override
  Future<void> crateApiPlayerPreloadTrack({
    required String path,
    required BigInt positionMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          sse_encode_u_64(positionMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 78,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerPreloadTrackConstMeta,
        argValues: [path, positionMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerPreloadTrackConstMeta => const TaskConstMeta(
    debugName: "preload_track",
    argNames: ["path", "positionMs"],
  );

  @override
  Future<void> crateApiPlayerPreloadTrackRef({
    required TrackRef track,
    required BigInt positionMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_track_ref(track, serializer);
          sse_encode_u_64(positionMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 79,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerPreloadTrackRefConstMeta,
        argValues: [track, positionMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerPreloadTrackRefConstMeta =>
      const TaskConstMeta(
        debugName: "preload_track_ref",
        argNames: ["track", "positionMs"],
      );

  @override
  Future<List<AudioDevice>> crateApiPlayerRefreshDevices() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 80,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_audio_device,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerRefreshDevicesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerRefreshDevicesConstMeta =>
      const TaskConstMeta(debugName: "refresh_devices", argNames: []);

  @override
  Future<ResampleQuality> crateApiPlayerTypesResampleQualityDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 81,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_resample_quality,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerTypesResampleQualityDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerTypesResampleQualityDefaultConstMeta =>
      const TaskConstMeta(debugName: "resample_quality_default", argNames: []);

  @override
  Future<void> crateApiPlayerSeekMs({required BigInt positionMs}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_64(positionMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 82,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerSeekMsConstMeta,
        argValues: [positionMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerSeekMsConstMeta =>
      const TaskConstMeta(debugName: "seek_ms", argNames: ["positionMs"]);

  @override
  Future<void> crateApiPlayerSetLfeMode({required LfeMode mode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_lfe_mode(mode, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 83,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerSetLfeModeConstMeta,
        argValues: [mode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerSetLfeModeConstMeta =>
      const TaskConstMeta(debugName: "set_lfe_mode", argNames: ["mode"]);

  @override
  Future<void> crateApiPlayerSetOutputDevice({
    required AudioBackend backend,
    String? deviceId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_audio_backend(backend, serializer);
          sse_encode_opt_String(deviceId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 84,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerSetOutputDeviceConstMeta,
        argValues: [backend, deviceId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerSetOutputDeviceConstMeta =>
      const TaskConstMeta(
        debugName: "set_output_device",
        argNames: ["backend", "deviceId"],
      );

  @override
  Future<void> crateApiPlayerSetOutputOptions({
    required bool matchTrackSampleRate,
    required bool gaplessPlayback,
    required bool seekTrackFade,
    required ResampleQuality resampleQuality,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_bool(matchTrackSampleRate, serializer);
          sse_encode_bool(gaplessPlayback, serializer);
          sse_encode_bool(seekTrackFade, serializer);
          sse_encode_resample_quality(resampleQuality, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 85,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerSetOutputOptionsConstMeta,
        argValues: [
          matchTrackSampleRate,
          gaplessPlayback,
          seekTrackFade,
          resampleQuality,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerSetOutputOptionsConstMeta =>
      const TaskConstMeta(
        debugName: "set_output_options",
        argNames: [
          "matchTrackSampleRate",
          "gaplessPlayback",
          "seekTrackFade",
          "resampleQuality",
        ],
      );

  @override
  Future<void> crateApiPlayerSetOutputSinkRoute({
    required OutputSinkRoute route,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_output_sink_route(route, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 86,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerSetOutputSinkRouteConstMeta,
        argValues: [route],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerSetOutputSinkRouteConstMeta =>
      const TaskConstMeta(
        debugName: "set_output_sink_route",
        argNames: ["route"],
      );

  @override
  Future<void> crateApiPlayerSetVolume({
    required double volume,
    required BigInt seq,
    required int rampMs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(volume, serializer);
          sse_encode_u_64(seq, serializer);
          sse_encode_u_32(rampMs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 87,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerSetVolumeConstMeta,
        argValues: [volume, seq, rampMs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerSetVolumeConstMeta => const TaskConstMeta(
    debugName: "set_volume",
    argNames: ["volume", "seq", "rampMs"],
  );

  @override
  Future<void> crateApiRuntimeShutdown() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 88,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiRuntimeShutdownConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRuntimeShutdownConstMeta =>
      const TaskConstMeta(debugName: "shutdown", argNames: []);

  @override
  Future<String> crateApiPlayerSourceListItemsJson({
    required String pluginId,
    required String typeId,
    required String configJson,
    required String requestJson,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pluginId, serializer);
          sse_encode_String(typeId, serializer);
          sse_encode_String(configJson, serializer);
          sse_encode_String(requestJson, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 89,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerSourceListItemsJsonConstMeta,
        argValues: [pluginId, typeId, configJson, requestJson],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerSourceListItemsJsonConstMeta =>
      const TaskConstMeta(
        debugName: "source_list_items_json",
        argNames: ["pluginId", "typeId", "configJson", "requestJson"],
      );

  @override
  Future<List<SourceCatalogTypeDescriptor>> crateApiPlayerSourceListTypes() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 90,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_source_catalog_type_descriptor,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerSourceListTypesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerSourceListTypesConstMeta =>
      const TaskConstMeta(debugName: "source_list_types", argNames: []);

  @override
  Future<void> crateApiPlayerStop() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 91,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerStopConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerStopConstMeta =>
      const TaskConstMeta(debugName: "stop", argNames: []);

  @override
  Future<void> crateApiPlayerSwitchTrackRef({
    required TrackRef track,
    required bool lazy,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_track_ref(track, serializer);
          sse_encode_bool(lazy, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 92,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPlayerSwitchTrackRefConstMeta,
        argValues: [track, lazy],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerSwitchTrackRefConstMeta =>
      const TaskConstMeta(
        debugName: "switch_track_ref",
        argNames: ["track", "lazy"],
      );

  @override
  Future<TrackRef> crateApiPlayerTypesTrackRefForLocalPath({
    required String path,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 93,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_track_ref,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerTypesTrackRefForLocalPathConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerTypesTrackRefForLocalPathConstMeta =>
      const TaskConstMeta(
        debugName: "track_ref_for_local_path",
        argNames: ["path"],
      );

  @override
  Future<TrackRef> crateApiPlayerTypesTrackRefNew({
    required String sourceId,
    required String trackId,
    required String locator,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(sourceId, serializer);
          sse_encode_String(trackId, serializer);
          sse_encode_String(locator, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 94,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_track_ref,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerTypesTrackRefNewConstMeta,
        argValues: [sourceId, trackId, locator],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerTypesTrackRefNewConstMeta =>
      const TaskConstMeta(
        debugName: "track_ref_new",
        argNames: ["sourceId", "trackId", "locator"],
      );

  @override
  Future<String> crateApiPlayerTypesTrackRefStableKey({
    required TrackRef that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_track_ref(that, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 95,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPlayerTypesTrackRefStableKeyConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPlayerTypesTrackRefStableKeyConstMeta =>
      const TaskConstMeta(
        debugName: "track_ref_stable_key",
        argNames: ["that"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  RustStreamSink<Event> dco_decode_StreamSink_event_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<LibraryEvent> dco_decode_StreamSink_library_event_Sse(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<LyricsEvent> dco_decode_StreamSink_lyrics_event_Sse(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<PluginRuntimeEvent>
  dco_decode_StreamSink_plugin_runtime_event_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AudioBackend dco_decode_audio_backend(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioBackend.values[raw as int];
  }

  @protected
  AudioDevice dco_decode_audio_device(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AudioDevice(
      backend: dco_decode_audio_backend(arr[0]),
      id: dco_decode_String(arr[1]),
      name: dco_decode_String(arr[2]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  DlnaRenderer dco_decode_box_autoadd_dlna_renderer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_dlna_renderer(raw);
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  LyricsDoc dco_decode_box_autoadd_lyrics_doc(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lyrics_doc(raw);
  }

  @protected
  LyricsQuery dco_decode_box_autoadd_lyrics_query(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lyrics_query(raw);
  }

  @protected
  OutputSinkRoute dco_decode_box_autoadd_output_sink_route(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_output_sink_route(raw);
  }

  @protected
  TrackDecodeInfo dco_decode_box_autoadd_track_decode_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_track_decode_info(raw);
  }

  @protected
  TrackRef dco_decode_box_autoadd_track_ref(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_track_ref(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  DlnaHttpServerInfo dco_decode_dlna_http_server_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return DlnaHttpServerInfo(
      listenAddr: dco_decode_String(arr[0]),
      baseUrl: dco_decode_String(arr[1]),
    );
  }

  @protected
  DlnaPositionInfo dco_decode_dlna_position_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return DlnaPositionInfo(
      relTimeMs: dco_decode_u_64(arr[0]),
      trackDurationMs: dco_decode_opt_box_autoadd_u_64(arr[1]),
    );
  }

  @protected
  DlnaRenderer dco_decode_dlna_renderer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return DlnaRenderer(
      usn: dco_decode_String(arr[0]),
      location: dco_decode_String(arr[1]),
      friendlyName: dco_decode_String(arr[2]),
      avTransportControlUrl: dco_decode_opt_String(arr[3]),
      avTransportServiceType: dco_decode_opt_String(arr[4]),
      renderingControlUrl: dco_decode_opt_String(arr[5]),
      renderingControlServiceType: dco_decode_opt_String(arr[6]),
    );
  }

  @protected
  DlnaSsdpDevice dco_decode_dlna_ssdp_device(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return DlnaSsdpDevice(
      usn: dco_decode_String(arr[0]),
      st: dco_decode_String(arr[1]),
      location: dco_decode_String(arr[2]),
      server: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  DlnaTransportInfo dco_decode_dlna_transport_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return DlnaTransportInfo(
      currentTransportState: dco_decode_String(arr[0]),
      currentTransportStatus: dco_decode_opt_String(arr[1]),
      currentSpeed: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  DspChainItem dco_decode_dsp_chain_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return DspChainItem(
      pluginId: dco_decode_String(arr[0]),
      typeId: dco_decode_String(arr[1]),
      configJson: dco_decode_String(arr[2]),
    );
  }

  @protected
  DspTypeDescriptor dco_decode_dsp_type_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return DspTypeDescriptor(
      pluginId: dco_decode_String(arr[0]),
      pluginName: dco_decode_String(arr[1]),
      typeId: dco_decode_String(arr[2]),
      displayName: dco_decode_String(arr[3]),
      configSchemaJson: dco_decode_String(arr[4]),
      defaultConfigJson: dco_decode_String(arr[5]),
    );
  }

  @protected
  Event dco_decode_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Event_StateChanged(state: dco_decode_player_state(raw[1]));
      case 1:
        return Event_Position(
          ms: dco_decode_i_64(raw[1]),
          path: dco_decode_String(raw[2]),
          sessionId: dco_decode_u_64(raw[3]),
        );
      case 2:
        return Event_TrackChanged(path: dco_decode_String(raw[1]));
      case 3:
        return Event_PlaybackEnded(path: dco_decode_String(raw[1]));
      case 4:
        return Event_VolumeChanged(
          volume: dco_decode_f_32(raw[1]),
          seq: dco_decode_u_64(raw[2]),
        );
      case 5:
        return Event_AudioStart();
      case 6:
        return Event_AudioEnd();
      case 7:
        return Event_Error(message: dco_decode_String(raw[1]));
      case 8:
        return Event_Log(message: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  LfeMode dco_decode_lfe_mode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LfeMode.values[raw as int];
  }

  @protected
  LibraryEvent dco_decode_library_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LibraryEvent_Changed();
      case 1:
        return LibraryEvent_ScanProgress(
          scanned: dco_decode_i_64(raw[1]),
          updated: dco_decode_i_64(raw[2]),
          skipped: dco_decode_i_64(raw[3]),
          errors: dco_decode_i_64(raw[4]),
        );
      case 2:
        return LibraryEvent_ScanFinished(
          durationMs: dco_decode_i_64(raw[1]),
          scanned: dco_decode_i_64(raw[2]),
          updated: dco_decode_i_64(raw[3]),
          skipped: dco_decode_i_64(raw[4]),
          errors: dco_decode_i_64(raw[5]),
        );
      case 3:
        return LibraryEvent_Error(message: dco_decode_String(raw[1]));
      case 4:
        return LibraryEvent_Log(message: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<AudioDevice> dco_decode_list_audio_device(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_audio_device).toList();
  }

  @protected
  List<DlnaRenderer> dco_decode_list_dlna_renderer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dlna_renderer).toList();
  }

  @protected
  List<DlnaSsdpDevice> dco_decode_list_dlna_ssdp_device(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dlna_ssdp_device).toList();
  }

  @protected
  List<DspChainItem> dco_decode_list_dsp_chain_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dsp_chain_item).toList();
  }

  @protected
  List<DspTypeDescriptor> dco_decode_list_dsp_type_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dsp_type_descriptor).toList();
  }

  @protected
  List<LyricLine> dco_decode_list_lyric_line(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_lyric_line).toList();
  }

  @protected
  List<LyricsProviderTypeDescriptor>
  dco_decode_list_lyrics_provider_type_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_lyrics_provider_type_descriptor)
        .toList();
  }

  @protected
  List<LyricsSearchCandidate> dco_decode_list_lyrics_search_candidate(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_lyrics_search_candidate)
        .toList();
  }

  @protected
  List<OutputSinkTypeDescriptor> dco_decode_list_output_sink_type_descriptor(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_output_sink_type_descriptor)
        .toList();
  }

  @protected
  List<PlaylistLite> dco_decode_list_playlist_lite(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_playlist_lite).toList();
  }

  @protected
  List<PluginDescriptor> dco_decode_list_plugin_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_plugin_descriptor).toList();
  }

  @protected
  Int64List dco_decode_list_prim_i_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeInt64List(raw);
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<SourceCatalogTypeDescriptor>
  dco_decode_list_source_catalog_type_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_source_catalog_type_descriptor)
        .toList();
  }

  @protected
  List<TrackLite> dco_decode_list_track_lite(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_track_lite).toList();
  }

  @protected
  LyricLine dco_decode_lyric_line(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LyricLine(
      startMs: dco_decode_opt_box_autoadd_i_64(arr[0]),
      endMs: dco_decode_opt_box_autoadd_i_64(arr[1]),
      text: dco_decode_String(arr[2]),
    );
  }

  @protected
  LyricsDoc dco_decode_lyrics_doc(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LyricsDoc(
      trackKey: dco_decode_String(arr[0]),
      source: dco_decode_String(arr[1]),
      isSynced: dco_decode_bool(arr[2]),
      lines: dco_decode_list_lyric_line(arr[3]),
    );
  }

  @protected
  LyricsEvent dco_decode_lyrics_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LyricsEvent_Loading(trackKey: dco_decode_String(raw[1]));
      case 1:
        return LyricsEvent_Ready(
          trackKey: dco_decode_String(raw[1]),
          doc: dco_decode_box_autoadd_lyrics_doc(raw[2]),
        );
      case 2:
        return LyricsEvent_Cursor(
          trackKey: dco_decode_String(raw[1]),
          lineIndex: dco_decode_i_64(raw[2]),
        );
      case 3:
        return LyricsEvent_Empty(trackKey: dco_decode_String(raw[1]));
      case 4:
        return LyricsEvent_Error(
          trackKey: dco_decode_String(raw[1]),
          message: dco_decode_String(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LyricsProviderTypeDescriptor dco_decode_lyrics_provider_type_descriptor(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LyricsProviderTypeDescriptor(
      pluginId: dco_decode_String(arr[0]),
      pluginName: dco_decode_String(arr[1]),
      typeId: dco_decode_String(arr[2]),
      displayName: dco_decode_String(arr[3]),
    );
  }

  @protected
  LyricsQuery dco_decode_lyrics_query(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return LyricsQuery(
      trackKey: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      artist: dco_decode_opt_String(arr[2]),
      album: dco_decode_opt_String(arr[3]),
      durationMs: dco_decode_opt_box_autoadd_i_64(arr[4]),
    );
  }

  @protected
  LyricsSearchCandidate dco_decode_lyrics_search_candidate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return LyricsSearchCandidate(
      candidateId: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      artist: dco_decode_opt_String(arr[2]),
      album: dco_decode_opt_String(arr[3]),
      source: dco_decode_String(arr[4]),
      isSynced: dco_decode_bool(arr[5]),
      preview: dco_decode_opt_String(arr[6]),
      doc: dco_decode_lyrics_doc(arr[7]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  TrackDecodeInfo? dco_decode_opt_box_autoadd_track_decode_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_track_decode_info(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_16(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  OutputSinkRoute dco_decode_output_sink_route(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return OutputSinkRoute(
      pluginId: dco_decode_String(arr[0]),
      typeId: dco_decode_String(arr[1]),
      configJson: dco_decode_String(arr[2]),
      targetJson: dco_decode_String(arr[3]),
    );
  }

  @protected
  OutputSinkTypeDescriptor dco_decode_output_sink_type_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return OutputSinkTypeDescriptor(
      pluginId: dco_decode_String(arr[0]),
      pluginName: dco_decode_String(arr[1]),
      typeId: dco_decode_String(arr[2]),
      displayName: dco_decode_String(arr[3]),
      configSchemaJson: dco_decode_String(arr[4]),
      defaultConfigJson: dco_decode_String(arr[5]),
    );
  }

  @protected
  PlayerState dco_decode_player_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PlayerState.values[raw as int];
  }

  @protected
  PlaylistLite dco_decode_playlist_lite(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return PlaylistLite(
      id: dco_decode_i_64(arr[0]),
      name: dco_decode_String(arr[1]),
      systemKey: dco_decode_opt_String(arr[2]),
      trackCount: dco_decode_i_64(arr[3]),
      firstTrackId: dco_decode_opt_box_autoadd_i_64(arr[4]),
    );
  }

  @protected
  PluginDescriptor dco_decode_plugin_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PluginDescriptor(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
    );
  }

  @protected
  PluginRuntimeEvent dco_decode_plugin_runtime_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PluginRuntimeEvent(
      pluginId: dco_decode_String(arr[0]),
      kind: dco_decode_plugin_runtime_kind(arr[1]),
      payloadJson: dco_decode_String(arr[2]),
    );
  }

  @protected
  PluginRuntimeKind dco_decode_plugin_runtime_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PluginRuntimeKind.values[raw as int];
  }

  @protected
  ResampleQuality dco_decode_resample_quality(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ResampleQuality.values[raw as int];
  }

  @protected
  SourceCatalogTypeDescriptor dco_decode_source_catalog_type_descriptor(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return SourceCatalogTypeDescriptor(
      pluginId: dco_decode_String(arr[0]),
      pluginName: dco_decode_String(arr[1]),
      typeId: dco_decode_String(arr[2]),
      displayName: dco_decode_String(arr[3]),
      configSchemaJson: dco_decode_String(arr[4]),
      defaultConfigJson: dco_decode_String(arr[5]),
    );
  }

  @protected
  TrackDecodeInfo dco_decode_track_decode_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return TrackDecodeInfo(
      sampleRate: dco_decode_u_32(arr[0]),
      channels: dco_decode_u_16(arr[1]),
      durationMs: dco_decode_opt_box_autoadd_u_64(arr[2]),
      metadataJson: dco_decode_opt_String(arr[3]),
      decoderPluginId: dco_decode_opt_String(arr[4]),
      decoderTypeId: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  TrackLite dco_decode_track_lite(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return TrackLite(
      id: dco_decode_i_64(arr[0]),
      path: dco_decode_String(arr[1]),
      title: dco_decode_opt_String(arr[2]),
      artist: dco_decode_opt_String(arr[3]),
      album: dco_decode_opt_String(arr[4]),
      durationMs: dco_decode_opt_box_autoadd_i_64(arr[5]),
    );
  }

  @protected
  TrackRef dco_decode_track_ref(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return TrackRef(
      sourceId: dco_decode_String(arr[0]),
      trackId: dco_decode_String(arr[1]),
      locator: dco_decode_String(arr[2]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  RustStreamSink<Event> sse_decode_StreamSink_event_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<LibraryEvent> sse_decode_StreamSink_library_event_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<LyricsEvent> sse_decode_StreamSink_lyrics_event_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<PluginRuntimeEvent>
  sse_decode_StreamSink_plugin_runtime_event_Sse(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AudioBackend sse_decode_audio_backend(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return AudioBackend.values[inner];
  }

  @protected
  AudioDevice sse_decode_audio_device(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_backend = sse_decode_audio_backend(deserializer);
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    return AudioDevice(backend: var_backend, id: var_id, name: var_name);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  DlnaRenderer sse_decode_box_autoadd_dlna_renderer(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_dlna_renderer(deserializer));
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  LyricsDoc sse_decode_box_autoadd_lyrics_doc(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lyrics_doc(deserializer));
  }

  @protected
  LyricsQuery sse_decode_box_autoadd_lyrics_query(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lyrics_query(deserializer));
  }

  @protected
  OutputSinkRoute sse_decode_box_autoadd_output_sink_route(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_output_sink_route(deserializer));
  }

  @protected
  TrackDecodeInfo sse_decode_box_autoadd_track_decode_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_track_decode_info(deserializer));
  }

  @protected
  TrackRef sse_decode_box_autoadd_track_ref(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_track_ref(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_16(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  DlnaHttpServerInfo sse_decode_dlna_http_server_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_listenAddr = sse_decode_String(deserializer);
    var var_baseUrl = sse_decode_String(deserializer);
    return DlnaHttpServerInfo(listenAddr: var_listenAddr, baseUrl: var_baseUrl);
  }

  @protected
  DlnaPositionInfo sse_decode_dlna_position_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_relTimeMs = sse_decode_u_64(deserializer);
    var var_trackDurationMs = sse_decode_opt_box_autoadd_u_64(deserializer);
    return DlnaPositionInfo(
      relTimeMs: var_relTimeMs,
      trackDurationMs: var_trackDurationMs,
    );
  }

  @protected
  DlnaRenderer sse_decode_dlna_renderer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_usn = sse_decode_String(deserializer);
    var var_location = sse_decode_String(deserializer);
    var var_friendlyName = sse_decode_String(deserializer);
    var var_avTransportControlUrl = sse_decode_opt_String(deserializer);
    var var_avTransportServiceType = sse_decode_opt_String(deserializer);
    var var_renderingControlUrl = sse_decode_opt_String(deserializer);
    var var_renderingControlServiceType = sse_decode_opt_String(deserializer);
    return DlnaRenderer(
      usn: var_usn,
      location: var_location,
      friendlyName: var_friendlyName,
      avTransportControlUrl: var_avTransportControlUrl,
      avTransportServiceType: var_avTransportServiceType,
      renderingControlUrl: var_renderingControlUrl,
      renderingControlServiceType: var_renderingControlServiceType,
    );
  }

  @protected
  DlnaSsdpDevice sse_decode_dlna_ssdp_device(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_usn = sse_decode_String(deserializer);
    var var_st = sse_decode_String(deserializer);
    var var_location = sse_decode_String(deserializer);
    var var_server = sse_decode_opt_String(deserializer);
    return DlnaSsdpDevice(
      usn: var_usn,
      st: var_st,
      location: var_location,
      server: var_server,
    );
  }

  @protected
  DlnaTransportInfo sse_decode_dlna_transport_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_currentTransportState = sse_decode_String(deserializer);
    var var_currentTransportStatus = sse_decode_opt_String(deserializer);
    var var_currentSpeed = sse_decode_opt_String(deserializer);
    return DlnaTransportInfo(
      currentTransportState: var_currentTransportState,
      currentTransportStatus: var_currentTransportStatus,
      currentSpeed: var_currentSpeed,
    );
  }

  @protected
  DspChainItem sse_decode_dsp_chain_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pluginId = sse_decode_String(deserializer);
    var var_typeId = sse_decode_String(deserializer);
    var var_configJson = sse_decode_String(deserializer);
    return DspChainItem(
      pluginId: var_pluginId,
      typeId: var_typeId,
      configJson: var_configJson,
    );
  }

  @protected
  DspTypeDescriptor sse_decode_dsp_type_descriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pluginId = sse_decode_String(deserializer);
    var var_pluginName = sse_decode_String(deserializer);
    var var_typeId = sse_decode_String(deserializer);
    var var_displayName = sse_decode_String(deserializer);
    var var_configSchemaJson = sse_decode_String(deserializer);
    var var_defaultConfigJson = sse_decode_String(deserializer);
    return DspTypeDescriptor(
      pluginId: var_pluginId,
      pluginName: var_pluginName,
      typeId: var_typeId,
      displayName: var_displayName,
      configSchemaJson: var_configSchemaJson,
      defaultConfigJson: var_defaultConfigJson,
    );
  }

  @protected
  Event sse_decode_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_state = sse_decode_player_state(deserializer);
        return Event_StateChanged(state: var_state);
      case 1:
        var var_ms = sse_decode_i_64(deserializer);
        var var_path = sse_decode_String(deserializer);
        var var_sessionId = sse_decode_u_64(deserializer);
        return Event_Position(
          ms: var_ms,
          path: var_path,
          sessionId: var_sessionId,
        );
      case 2:
        var var_path = sse_decode_String(deserializer);
        return Event_TrackChanged(path: var_path);
      case 3:
        var var_path = sse_decode_String(deserializer);
        return Event_PlaybackEnded(path: var_path);
      case 4:
        var var_volume = sse_decode_f_32(deserializer);
        var var_seq = sse_decode_u_64(deserializer);
        return Event_VolumeChanged(volume: var_volume, seq: var_seq);
      case 5:
        return Event_AudioStart();
      case 6:
        return Event_AudioEnd();
      case 7:
        var var_message = sse_decode_String(deserializer);
        return Event_Error(message: var_message);
      case 8:
        var var_message = sse_decode_String(deserializer);
        return Event_Log(message: var_message);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  LfeMode sse_decode_lfe_mode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return LfeMode.values[inner];
  }

  @protected
  LibraryEvent sse_decode_library_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return LibraryEvent_Changed();
      case 1:
        var var_scanned = sse_decode_i_64(deserializer);
        var var_updated = sse_decode_i_64(deserializer);
        var var_skipped = sse_decode_i_64(deserializer);
        var var_errors = sse_decode_i_64(deserializer);
        return LibraryEvent_ScanProgress(
          scanned: var_scanned,
          updated: var_updated,
          skipped: var_skipped,
          errors: var_errors,
        );
      case 2:
        var var_durationMs = sse_decode_i_64(deserializer);
        var var_scanned = sse_decode_i_64(deserializer);
        var var_updated = sse_decode_i_64(deserializer);
        var var_skipped = sse_decode_i_64(deserializer);
        var var_errors = sse_decode_i_64(deserializer);
        return LibraryEvent_ScanFinished(
          durationMs: var_durationMs,
          scanned: var_scanned,
          updated: var_updated,
          skipped: var_skipped,
          errors: var_errors,
        );
      case 3:
        var var_message = sse_decode_String(deserializer);
        return LibraryEvent_Error(message: var_message);
      case 4:
        var var_message = sse_decode_String(deserializer);
        return LibraryEvent_Log(message: var_message);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<AudioDevice> sse_decode_list_audio_device(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AudioDevice>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_audio_device(deserializer));
    }
    return ans_;
  }

  @protected
  List<DlnaRenderer> sse_decode_list_dlna_renderer(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DlnaRenderer>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dlna_renderer(deserializer));
    }
    return ans_;
  }

  @protected
  List<DlnaSsdpDevice> sse_decode_list_dlna_ssdp_device(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DlnaSsdpDevice>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dlna_ssdp_device(deserializer));
    }
    return ans_;
  }

  @protected
  List<DspChainItem> sse_decode_list_dsp_chain_item(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DspChainItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dsp_chain_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<DspTypeDescriptor> sse_decode_list_dsp_type_descriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DspTypeDescriptor>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dsp_type_descriptor(deserializer));
    }
    return ans_;
  }

  @protected
  List<LyricLine> sse_decode_list_lyric_line(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LyricLine>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_lyric_line(deserializer));
    }
    return ans_;
  }

  @protected
  List<LyricsProviderTypeDescriptor>
  sse_decode_list_lyrics_provider_type_descriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LyricsProviderTypeDescriptor>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_lyrics_provider_type_descriptor(deserializer));
    }
    return ans_;
  }

  @protected
  List<LyricsSearchCandidate> sse_decode_list_lyrics_search_candidate(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LyricsSearchCandidate>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_lyrics_search_candidate(deserializer));
    }
    return ans_;
  }

  @protected
  List<OutputSinkTypeDescriptor> sse_decode_list_output_sink_type_descriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OutputSinkTypeDescriptor>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_output_sink_type_descriptor(deserializer));
    }
    return ans_;
  }

  @protected
  List<PlaylistLite> sse_decode_list_playlist_lite(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PlaylistLite>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_playlist_lite(deserializer));
    }
    return ans_;
  }

  @protected
  List<PluginDescriptor> sse_decode_list_plugin_descriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PluginDescriptor>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_plugin_descriptor(deserializer));
    }
    return ans_;
  }

  @protected
  Int64List sse_decode_list_prim_i_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt64List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<SourceCatalogTypeDescriptor>
  sse_decode_list_source_catalog_type_descriptor(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SourceCatalogTypeDescriptor>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_source_catalog_type_descriptor(deserializer));
    }
    return ans_;
  }

  @protected
  List<TrackLite> sse_decode_list_track_lite(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TrackLite>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_track_lite(deserializer));
    }
    return ans_;
  }

  @protected
  LyricLine sse_decode_lyric_line(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_startMs = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_endMs = sse_decode_opt_box_autoadd_i_64(deserializer);
    var var_text = sse_decode_String(deserializer);
    return LyricLine(startMs: var_startMs, endMs: var_endMs, text: var_text);
  }

  @protected
  LyricsDoc sse_decode_lyrics_doc(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_trackKey = sse_decode_String(deserializer);
    var var_source = sse_decode_String(deserializer);
    var var_isSynced = sse_decode_bool(deserializer);
    var var_lines = sse_decode_list_lyric_line(deserializer);
    return LyricsDoc(
      trackKey: var_trackKey,
      source: var_source,
      isSynced: var_isSynced,
      lines: var_lines,
    );
  }

  @protected
  LyricsEvent sse_decode_lyrics_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_trackKey = sse_decode_String(deserializer);
        return LyricsEvent_Loading(trackKey: var_trackKey);
      case 1:
        var var_trackKey = sse_decode_String(deserializer);
        var var_doc = sse_decode_box_autoadd_lyrics_doc(deserializer);
        return LyricsEvent_Ready(trackKey: var_trackKey, doc: var_doc);
      case 2:
        var var_trackKey = sse_decode_String(deserializer);
        var var_lineIndex = sse_decode_i_64(deserializer);
        return LyricsEvent_Cursor(
          trackKey: var_trackKey,
          lineIndex: var_lineIndex,
        );
      case 3:
        var var_trackKey = sse_decode_String(deserializer);
        return LyricsEvent_Empty(trackKey: var_trackKey);
      case 4:
        var var_trackKey = sse_decode_String(deserializer);
        var var_message = sse_decode_String(deserializer);
        return LyricsEvent_Error(trackKey: var_trackKey, message: var_message);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LyricsProviderTypeDescriptor sse_decode_lyrics_provider_type_descriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pluginId = sse_decode_String(deserializer);
    var var_pluginName = sse_decode_String(deserializer);
    var var_typeId = sse_decode_String(deserializer);
    var var_displayName = sse_decode_String(deserializer);
    return LyricsProviderTypeDescriptor(
      pluginId: var_pluginId,
      pluginName: var_pluginName,
      typeId: var_typeId,
      displayName: var_displayName,
    );
  }

  @protected
  LyricsQuery sse_decode_lyrics_query(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_trackKey = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_artist = sse_decode_opt_String(deserializer);
    var var_album = sse_decode_opt_String(deserializer);
    var var_durationMs = sse_decode_opt_box_autoadd_i_64(deserializer);
    return LyricsQuery(
      trackKey: var_trackKey,
      title: var_title,
      artist: var_artist,
      album: var_album,
      durationMs: var_durationMs,
    );
  }

  @protected
  LyricsSearchCandidate sse_decode_lyrics_search_candidate(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_candidateId = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_artist = sse_decode_opt_String(deserializer);
    var var_album = sse_decode_opt_String(deserializer);
    var var_source = sse_decode_String(deserializer);
    var var_isSynced = sse_decode_bool(deserializer);
    var var_preview = sse_decode_opt_String(deserializer);
    var var_doc = sse_decode_lyrics_doc(deserializer);
    return LyricsSearchCandidate(
      candidateId: var_candidateId,
      title: var_title,
      artist: var_artist,
      album: var_album,
      source: var_source,
      isSynced: var_isSynced,
      preview: var_preview,
      doc: var_doc,
    );
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  TrackDecodeInfo? sse_decode_opt_box_autoadd_track_decode_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_track_decode_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_16(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutputSinkRoute sse_decode_output_sink_route(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pluginId = sse_decode_String(deserializer);
    var var_typeId = sse_decode_String(deserializer);
    var var_configJson = sse_decode_String(deserializer);
    var var_targetJson = sse_decode_String(deserializer);
    return OutputSinkRoute(
      pluginId: var_pluginId,
      typeId: var_typeId,
      configJson: var_configJson,
      targetJson: var_targetJson,
    );
  }

  @protected
  OutputSinkTypeDescriptor sse_decode_output_sink_type_descriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pluginId = sse_decode_String(deserializer);
    var var_pluginName = sse_decode_String(deserializer);
    var var_typeId = sse_decode_String(deserializer);
    var var_displayName = sse_decode_String(deserializer);
    var var_configSchemaJson = sse_decode_String(deserializer);
    var var_defaultConfigJson = sse_decode_String(deserializer);
    return OutputSinkTypeDescriptor(
      pluginId: var_pluginId,
      pluginName: var_pluginName,
      typeId: var_typeId,
      displayName: var_displayName,
      configSchemaJson: var_configSchemaJson,
      defaultConfigJson: var_defaultConfigJson,
    );
  }

  @protected
  PlayerState sse_decode_player_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PlayerState.values[inner];
  }

  @protected
  PlaylistLite sse_decode_playlist_lite(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_systemKey = sse_decode_opt_String(deserializer);
    var var_trackCount = sse_decode_i_64(deserializer);
    var var_firstTrackId = sse_decode_opt_box_autoadd_i_64(deserializer);
    return PlaylistLite(
      id: var_id,
      name: var_name,
      systemKey: var_systemKey,
      trackCount: var_trackCount,
      firstTrackId: var_firstTrackId,
    );
  }

  @protected
  PluginDescriptor sse_decode_plugin_descriptor(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    return PluginDescriptor(id: var_id, name: var_name);
  }

  @protected
  PluginRuntimeEvent sse_decode_plugin_runtime_event(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pluginId = sse_decode_String(deserializer);
    var var_kind = sse_decode_plugin_runtime_kind(deserializer);
    var var_payloadJson = sse_decode_String(deserializer);
    return PluginRuntimeEvent(
      pluginId: var_pluginId,
      kind: var_kind,
      payloadJson: var_payloadJson,
    );
  }

  @protected
  PluginRuntimeKind sse_decode_plugin_runtime_kind(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PluginRuntimeKind.values[inner];
  }

  @protected
  ResampleQuality sse_decode_resample_quality(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ResampleQuality.values[inner];
  }

  @protected
  SourceCatalogTypeDescriptor sse_decode_source_catalog_type_descriptor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pluginId = sse_decode_String(deserializer);
    var var_pluginName = sse_decode_String(deserializer);
    var var_typeId = sse_decode_String(deserializer);
    var var_displayName = sse_decode_String(deserializer);
    var var_configSchemaJson = sse_decode_String(deserializer);
    var var_defaultConfigJson = sse_decode_String(deserializer);
    return SourceCatalogTypeDescriptor(
      pluginId: var_pluginId,
      pluginName: var_pluginName,
      typeId: var_typeId,
      displayName: var_displayName,
      configSchemaJson: var_configSchemaJson,
      defaultConfigJson: var_defaultConfigJson,
    );
  }

  @protected
  TrackDecodeInfo sse_decode_track_decode_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sampleRate = sse_decode_u_32(deserializer);
    var var_channels = sse_decode_u_16(deserializer);
    var var_durationMs = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_metadataJson = sse_decode_opt_String(deserializer);
    var var_decoderPluginId = sse_decode_opt_String(deserializer);
    var var_decoderTypeId = sse_decode_opt_String(deserializer);
    return TrackDecodeInfo(
      sampleRate: var_sampleRate,
      channels: var_channels,
      durationMs: var_durationMs,
      metadataJson: var_metadataJson,
      decoderPluginId: var_decoderPluginId,
      decoderTypeId: var_decoderTypeId,
    );
  }

  @protected
  TrackLite sse_decode_track_lite(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_path = sse_decode_String(deserializer);
    var var_title = sse_decode_opt_String(deserializer);
    var var_artist = sse_decode_opt_String(deserializer);
    var var_album = sse_decode_opt_String(deserializer);
    var var_durationMs = sse_decode_opt_box_autoadd_i_64(deserializer);
    return TrackLite(
      id: var_id,
      path: var_path,
      title: var_title,
      artist: var_artist,
      album: var_album,
      durationMs: var_durationMs,
    );
  }

  @protected
  TrackRef sse_decode_track_ref(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sourceId = sse_decode_String(deserializer);
    var var_trackId = sse_decode_String(deserializer);
    var var_locator = sse_decode_String(deserializer);
    return TrackRef(
      sourceId: var_sourceId,
      trackId: var_trackId,
      locator: var_locator,
    );
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_StreamSink_event_Sse(
    RustStreamSink<Event> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_event,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_library_event_Sse(
    RustStreamSink<LibraryEvent> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_library_event,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_lyrics_event_Sse(
    RustStreamSink<LyricsEvent> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_lyrics_event,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_plugin_runtime_event_Sse(
    RustStreamSink<PluginRuntimeEvent> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_plugin_runtime_event,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_audio_backend(AudioBackend self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_audio_device(AudioDevice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_backend(self.backend, serializer);
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_dlna_renderer(
    DlnaRenderer self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_dlna_renderer(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(
    PlatformInt64 self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lyrics_doc(
    LyricsDoc self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lyrics_doc(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lyrics_query(
    LyricsQuery self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lyrics_query(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_output_sink_route(
    OutputSinkRoute self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_output_sink_route(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_track_decode_info(
    TrackDecodeInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_track_decode_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_track_ref(
    TrackRef self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_track_ref(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_dlna_http_server_info(
    DlnaHttpServerInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.listenAddr, serializer);
    sse_encode_String(self.baseUrl, serializer);
  }

  @protected
  void sse_encode_dlna_position_info(
    DlnaPositionInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.relTimeMs, serializer);
    sse_encode_opt_box_autoadd_u_64(self.trackDurationMs, serializer);
  }

  @protected
  void sse_encode_dlna_renderer(DlnaRenderer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.usn, serializer);
    sse_encode_String(self.location, serializer);
    sse_encode_String(self.friendlyName, serializer);
    sse_encode_opt_String(self.avTransportControlUrl, serializer);
    sse_encode_opt_String(self.avTransportServiceType, serializer);
    sse_encode_opt_String(self.renderingControlUrl, serializer);
    sse_encode_opt_String(self.renderingControlServiceType, serializer);
  }

  @protected
  void sse_encode_dlna_ssdp_device(
    DlnaSsdpDevice self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.usn, serializer);
    sse_encode_String(self.st, serializer);
    sse_encode_String(self.location, serializer);
    sse_encode_opt_String(self.server, serializer);
  }

  @protected
  void sse_encode_dlna_transport_info(
    DlnaTransportInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.currentTransportState, serializer);
    sse_encode_opt_String(self.currentTransportStatus, serializer);
    sse_encode_opt_String(self.currentSpeed, serializer);
  }

  @protected
  void sse_encode_dsp_chain_item(DspChainItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.pluginId, serializer);
    sse_encode_String(self.typeId, serializer);
    sse_encode_String(self.configJson, serializer);
  }

  @protected
  void sse_encode_dsp_type_descriptor(
    DspTypeDescriptor self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.pluginId, serializer);
    sse_encode_String(self.pluginName, serializer);
    sse_encode_String(self.typeId, serializer);
    sse_encode_String(self.displayName, serializer);
    sse_encode_String(self.configSchemaJson, serializer);
    sse_encode_String(self.defaultConfigJson, serializer);
  }

  @protected
  void sse_encode_event(Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Event_StateChanged(state: final state):
        sse_encode_i_32(0, serializer);
        sse_encode_player_state(state, serializer);
      case Event_Position(
        ms: final ms,
        path: final path,
        sessionId: final sessionId,
      ):
        sse_encode_i_32(1, serializer);
        sse_encode_i_64(ms, serializer);
        sse_encode_String(path, serializer);
        sse_encode_u_64(sessionId, serializer);
      case Event_TrackChanged(path: final path):
        sse_encode_i_32(2, serializer);
        sse_encode_String(path, serializer);
      case Event_PlaybackEnded(path: final path):
        sse_encode_i_32(3, serializer);
        sse_encode_String(path, serializer);
      case Event_VolumeChanged(volume: final volume, seq: final seq):
        sse_encode_i_32(4, serializer);
        sse_encode_f_32(volume, serializer);
        sse_encode_u_64(seq, serializer);
      case Event_AudioStart():
        sse_encode_i_32(5, serializer);
      case Event_AudioEnd():
        sse_encode_i_32(6, serializer);
      case Event_Error(message: final message):
        sse_encode_i_32(7, serializer);
        sse_encode_String(message, serializer);
      case Event_Log(message: final message):
        sse_encode_i_32(8, serializer);
        sse_encode_String(message, serializer);
    }
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_lfe_mode(LfeMode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_library_event(LibraryEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LibraryEvent_Changed():
        sse_encode_i_32(0, serializer);
      case LibraryEvent_ScanProgress(
        scanned: final scanned,
        updated: final updated,
        skipped: final skipped,
        errors: final errors,
      ):
        sse_encode_i_32(1, serializer);
        sse_encode_i_64(scanned, serializer);
        sse_encode_i_64(updated, serializer);
        sse_encode_i_64(skipped, serializer);
        sse_encode_i_64(errors, serializer);
      case LibraryEvent_ScanFinished(
        durationMs: final durationMs,
        scanned: final scanned,
        updated: final updated,
        skipped: final skipped,
        errors: final errors,
      ):
        sse_encode_i_32(2, serializer);
        sse_encode_i_64(durationMs, serializer);
        sse_encode_i_64(scanned, serializer);
        sse_encode_i_64(updated, serializer);
        sse_encode_i_64(skipped, serializer);
        sse_encode_i_64(errors, serializer);
      case LibraryEvent_Error(message: final message):
        sse_encode_i_32(3, serializer);
        sse_encode_String(message, serializer);
      case LibraryEvent_Log(message: final message):
        sse_encode_i_32(4, serializer);
        sse_encode_String(message, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_audio_device(
    List<AudioDevice> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_audio_device(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dlna_renderer(
    List<DlnaRenderer> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dlna_renderer(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dlna_ssdp_device(
    List<DlnaSsdpDevice> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dlna_ssdp_device(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dsp_chain_item(
    List<DspChainItem> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dsp_chain_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dsp_type_descriptor(
    List<DspTypeDescriptor> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dsp_type_descriptor(item, serializer);
    }
  }

  @protected
  void sse_encode_list_lyric_line(
    List<LyricLine> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_lyric_line(item, serializer);
    }
  }

  @protected
  void sse_encode_list_lyrics_provider_type_descriptor(
    List<LyricsProviderTypeDescriptor> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_lyrics_provider_type_descriptor(item, serializer);
    }
  }

  @protected
  void sse_encode_list_lyrics_search_candidate(
    List<LyricsSearchCandidate> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_lyrics_search_candidate(item, serializer);
    }
  }

  @protected
  void sse_encode_list_output_sink_type_descriptor(
    List<OutputSinkTypeDescriptor> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_output_sink_type_descriptor(item, serializer);
    }
  }

  @protected
  void sse_encode_list_playlist_lite(
    List<PlaylistLite> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_playlist_lite(item, serializer);
    }
  }

  @protected
  void sse_encode_list_plugin_descriptor(
    List<PluginDescriptor> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_plugin_descriptor(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_i_64_strict(
    Int64List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_source_catalog_type_descriptor(
    List<SourceCatalogTypeDescriptor> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_source_catalog_type_descriptor(item, serializer);
    }
  }

  @protected
  void sse_encode_list_track_lite(
    List<TrackLite> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_track_lite(item, serializer);
    }
  }

  @protected
  void sse_encode_lyric_line(LyricLine self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_i_64(self.startMs, serializer);
    sse_encode_opt_box_autoadd_i_64(self.endMs, serializer);
    sse_encode_String(self.text, serializer);
  }

  @protected
  void sse_encode_lyrics_doc(LyricsDoc self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.trackKey, serializer);
    sse_encode_String(self.source, serializer);
    sse_encode_bool(self.isSynced, serializer);
    sse_encode_list_lyric_line(self.lines, serializer);
  }

  @protected
  void sse_encode_lyrics_event(LyricsEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LyricsEvent_Loading(trackKey: final trackKey):
        sse_encode_i_32(0, serializer);
        sse_encode_String(trackKey, serializer);
      case LyricsEvent_Ready(trackKey: final trackKey, doc: final doc):
        sse_encode_i_32(1, serializer);
        sse_encode_String(trackKey, serializer);
        sse_encode_box_autoadd_lyrics_doc(doc, serializer);
      case LyricsEvent_Cursor(
        trackKey: final trackKey,
        lineIndex: final lineIndex,
      ):
        sse_encode_i_32(2, serializer);
        sse_encode_String(trackKey, serializer);
        sse_encode_i_64(lineIndex, serializer);
      case LyricsEvent_Empty(trackKey: final trackKey):
        sse_encode_i_32(3, serializer);
        sse_encode_String(trackKey, serializer);
      case LyricsEvent_Error(trackKey: final trackKey, message: final message):
        sse_encode_i_32(4, serializer);
        sse_encode_String(trackKey, serializer);
        sse_encode_String(message, serializer);
    }
  }

  @protected
  void sse_encode_lyrics_provider_type_descriptor(
    LyricsProviderTypeDescriptor self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.pluginId, serializer);
    sse_encode_String(self.pluginName, serializer);
    sse_encode_String(self.typeId, serializer);
    sse_encode_String(self.displayName, serializer);
  }

  @protected
  void sse_encode_lyrics_query(LyricsQuery self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.trackKey, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_opt_String(self.artist, serializer);
    sse_encode_opt_String(self.album, serializer);
    sse_encode_opt_box_autoadd_i_64(self.durationMs, serializer);
  }

  @protected
  void sse_encode_lyrics_search_candidate(
    LyricsSearchCandidate self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.candidateId, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_opt_String(self.artist, serializer);
    sse_encode_opt_String(self.album, serializer);
    sse_encode_String(self.source, serializer);
    sse_encode_bool(self.isSynced, serializer);
    sse_encode_opt_String(self.preview, serializer);
    sse_encode_lyrics_doc(self.doc, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(
    PlatformInt64? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_track_decode_info(
    TrackDecodeInfo? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_track_decode_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_16(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_16(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_output_sink_route(
    OutputSinkRoute self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.pluginId, serializer);
    sse_encode_String(self.typeId, serializer);
    sse_encode_String(self.configJson, serializer);
    sse_encode_String(self.targetJson, serializer);
  }

  @protected
  void sse_encode_output_sink_type_descriptor(
    OutputSinkTypeDescriptor self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.pluginId, serializer);
    sse_encode_String(self.pluginName, serializer);
    sse_encode_String(self.typeId, serializer);
    sse_encode_String(self.displayName, serializer);
    sse_encode_String(self.configSchemaJson, serializer);
    sse_encode_String(self.defaultConfigJson, serializer);
  }

  @protected
  void sse_encode_player_state(PlayerState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_playlist_lite(PlaylistLite self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.systemKey, serializer);
    sse_encode_i_64(self.trackCount, serializer);
    sse_encode_opt_box_autoadd_i_64(self.firstTrackId, serializer);
  }

  @protected
  void sse_encode_plugin_descriptor(
    PluginDescriptor self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_plugin_runtime_event(
    PluginRuntimeEvent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.pluginId, serializer);
    sse_encode_plugin_runtime_kind(self.kind, serializer);
    sse_encode_String(self.payloadJson, serializer);
  }

  @protected
  void sse_encode_plugin_runtime_kind(
    PluginRuntimeKind self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_resample_quality(
    ResampleQuality self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_source_catalog_type_descriptor(
    SourceCatalogTypeDescriptor self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.pluginId, serializer);
    sse_encode_String(self.pluginName, serializer);
    sse_encode_String(self.typeId, serializer);
    sse_encode_String(self.displayName, serializer);
    sse_encode_String(self.configSchemaJson, serializer);
    sse_encode_String(self.defaultConfigJson, serializer);
  }

  @protected
  void sse_encode_track_decode_info(
    TrackDecodeInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.sampleRate, serializer);
    sse_encode_u_16(self.channels, serializer);
    sse_encode_opt_box_autoadd_u_64(self.durationMs, serializer);
    sse_encode_opt_String(self.metadataJson, serializer);
    sse_encode_opt_String(self.decoderPluginId, serializer);
    sse_encode_opt_String(self.decoderTypeId, serializer);
  }

  @protected
  void sse_encode_track_lite(TrackLite self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.path, serializer);
    sse_encode_opt_String(self.title, serializer);
    sse_encode_opt_String(self.artist, serializer);
    sse_encode_opt_String(self.album, serializer);
    sse_encode_opt_box_autoadd_i_64(self.durationMs, serializer);
  }

  @protected
  void sse_encode_track_ref(TrackRef self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sourceId, serializer);
    sse_encode_String(self.trackId, serializer);
    sse_encode_String(self.locator, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }
}
