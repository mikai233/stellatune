// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

// These functions are ignored because they have generic arguments: `config`, `config`, `from_payload`, `metadata`, `payload`, `set_metadata`, `target`, `with_config_target`, `with_config`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `as_str`

enum AudioBackend { shared, wasapiExclusive }

class AudioDevice {
  final AudioBackend backend;
  final String id;
  final String name;

  const AudioDevice({
    required this.backend,
    required this.id,
    required this.name,
  });

  @override
  int get hashCode => backend.hashCode ^ id.hashCode ^ name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioDevice &&
          runtimeType == other.runtimeType &&
          backend == other.backend &&
          id == other.id &&
          name == other.name;
}

class DspChainItem {
  final String pluginId;
  final String typeId;
  final String configJson;

  const DspChainItem({
    required this.pluginId,
    required this.typeId,
    required this.configJson,
  });

  @override
  int get hashCode => pluginId.hashCode ^ typeId.hashCode ^ configJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DspChainItem &&
          runtimeType == other.runtimeType &&
          pluginId == other.pluginId &&
          typeId == other.typeId &&
          configJson == other.configJson;
}

class DspTypeDescriptor {
  final String pluginId;
  final String pluginName;
  final String typeId;
  final String displayName;
  final String configSchemaJson;
  final String defaultConfigJson;

  const DspTypeDescriptor({
    required this.pluginId,
    required this.pluginName,
    required this.typeId,
    required this.displayName,
    required this.configSchemaJson,
    required this.defaultConfigJson,
  });

  @override
  int get hashCode =>
      pluginId.hashCode ^
      pluginName.hashCode ^
      typeId.hashCode ^
      displayName.hashCode ^
      configSchemaJson.hashCode ^
      defaultConfigJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DspTypeDescriptor &&
          runtimeType == other.runtimeType &&
          pluginId == other.pluginId &&
          pluginName == other.pluginName &&
          typeId == other.typeId &&
          displayName == other.displayName &&
          configSchemaJson == other.configSchemaJson &&
          defaultConfigJson == other.defaultConfigJson;
}

@freezed
sealed class Event with _$Event {
  const Event._();

  const factory Event.stateChanged({required PlayerState state}) =
      Event_StateChanged;
  const factory Event.position({
    required PlatformInt64 ms,
    required String path,
    required BigInt sessionId,
  }) = Event_Position;
  const factory Event.trackChanged({required String path}) = Event_TrackChanged;
  const factory Event.playbackEnded({required String path}) =
      Event_PlaybackEnded;
  const factory Event.volumeChanged({
    required double volume,
    required BigInt seq,
  }) = Event_VolumeChanged;
  const factory Event.audioStart() = Event_AudioStart;
  const factory Event.audioEnd() = Event_AudioEnd;
  const factory Event.error({required String message}) = Event_Error;
  const factory Event.log({required String message}) = Event_Log;
}

enum LfeMode {
  mute,
  mixToFront;

  static Future<LfeMode> default_() =>
      StellatuneApi.instance.api.crateApiPlayerTypesLfeModeDefault();
}

class LyricsProviderTypeDescriptor {
  final String pluginId;
  final String pluginName;
  final String typeId;
  final String displayName;

  const LyricsProviderTypeDescriptor({
    required this.pluginId,
    required this.pluginName,
    required this.typeId,
    required this.displayName,
  });

  @override
  int get hashCode =>
      pluginId.hashCode ^
      pluginName.hashCode ^
      typeId.hashCode ^
      displayName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LyricsProviderTypeDescriptor &&
          runtimeType == other.runtimeType &&
          pluginId == other.pluginId &&
          pluginName == other.pluginName &&
          typeId == other.typeId &&
          displayName == other.displayName;
}

class OutputSinkRoute {
  final String pluginId;
  final String typeId;
  final String configJson;
  final String targetJson;

  const OutputSinkRoute({
    required this.pluginId,
    required this.typeId,
    required this.configJson,
    required this.targetJson,
  });

  @override
  int get hashCode =>
      pluginId.hashCode ^
      typeId.hashCode ^
      configJson.hashCode ^
      targetJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OutputSinkRoute &&
          runtimeType == other.runtimeType &&
          pluginId == other.pluginId &&
          typeId == other.typeId &&
          configJson == other.configJson &&
          targetJson == other.targetJson;
}

class OutputSinkTypeDescriptor {
  final String pluginId;
  final String pluginName;
  final String typeId;
  final String displayName;
  final String configSchemaJson;
  final String defaultConfigJson;

  const OutputSinkTypeDescriptor({
    required this.pluginId,
    required this.pluginName,
    required this.typeId,
    required this.displayName,
    required this.configSchemaJson,
    required this.defaultConfigJson,
  });

  @override
  int get hashCode =>
      pluginId.hashCode ^
      pluginName.hashCode ^
      typeId.hashCode ^
      displayName.hashCode ^
      configSchemaJson.hashCode ^
      defaultConfigJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OutputSinkTypeDescriptor &&
          runtimeType == other.runtimeType &&
          pluginId == other.pluginId &&
          pluginName == other.pluginName &&
          typeId == other.typeId &&
          displayName == other.displayName &&
          configSchemaJson == other.configSchemaJson &&
          defaultConfigJson == other.defaultConfigJson;
}

enum PlayerState { stopped, playing, paused, buffering }

class PluginDescriptor {
  final String id;
  final String name;

  const PluginDescriptor({required this.id, required this.name});

  @override
  int get hashCode => id.hashCode ^ name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginDescriptor &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name;
}

class PluginRuntimeEvent {
  final String pluginId;
  final PluginRuntimeKind kind;
  final String payloadJson;

  const PluginRuntimeEvent({
    required this.pluginId,
    required this.kind,
    required this.payloadJson,
  });

  @override
  int get hashCode => pluginId.hashCode ^ kind.hashCode ^ payloadJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PluginRuntimeEvent &&
          runtimeType == other.runtimeType &&
          pluginId == other.pluginId &&
          kind == other.kind &&
          payloadJson == other.payloadJson;
}

enum PluginRuntimeKind { notify, control, controlResult, controlFinished }

enum ResampleQuality {
  fast,
  balanced,
  high,
  ultra;

  static Future<ResampleQuality> default_() =>
      StellatuneApi.instance.api.crateApiPlayerTypesResampleQualityDefault();
}

class SourceCatalogTypeDescriptor {
  final String pluginId;
  final String pluginName;
  final String typeId;
  final String displayName;
  final String configSchemaJson;
  final String defaultConfigJson;

  const SourceCatalogTypeDescriptor({
    required this.pluginId,
    required this.pluginName,
    required this.typeId,
    required this.displayName,
    required this.configSchemaJson,
    required this.defaultConfigJson,
  });

  @override
  int get hashCode =>
      pluginId.hashCode ^
      pluginName.hashCode ^
      typeId.hashCode ^
      displayName.hashCode ^
      configSchemaJson.hashCode ^
      defaultConfigJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceCatalogTypeDescriptor &&
          runtimeType == other.runtimeType &&
          pluginId == other.pluginId &&
          pluginName == other.pluginName &&
          typeId == other.typeId &&
          displayName == other.displayName &&
          configSchemaJson == other.configSchemaJson &&
          defaultConfigJson == other.defaultConfigJson;
}

class TrackDecodeInfo {
  final int sampleRate;
  final int channels;
  final BigInt? durationMs;
  final String? metadataJson;
  final String? decoderPluginId;
  final String? decoderTypeId;

  const TrackDecodeInfo({
    required this.sampleRate,
    required this.channels,
    this.durationMs,
    this.metadataJson,
    this.decoderPluginId,
    this.decoderTypeId,
  });

  @override
  int get hashCode =>
      sampleRate.hashCode ^
      channels.hashCode ^
      durationMs.hashCode ^
      metadataJson.hashCode ^
      decoderPluginId.hashCode ^
      decoderTypeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TrackDecodeInfo &&
          runtimeType == other.runtimeType &&
          sampleRate == other.sampleRate &&
          channels == other.channels &&
          durationMs == other.durationMs &&
          metadataJson == other.metadataJson &&
          decoderPluginId == other.decoderPluginId &&
          decoderTypeId == other.decoderTypeId;
}

class TrackPlayability {
  final TrackRef track;
  final bool playable;
  final String? reason;

  const TrackPlayability({
    required this.track,
    required this.playable,
    this.reason,
  });

  @override
  int get hashCode => track.hashCode ^ playable.hashCode ^ reason.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TrackPlayability &&
          runtimeType == other.runtimeType &&
          track == other.track &&
          playable == other.playable &&
          reason == other.reason;
}

class TrackRef {
  final String sourceId;
  final String trackId;
  final String locator;

  const TrackRef({
    required this.sourceId,
    required this.trackId,
    required this.locator,
  });

  static Future<TrackRef> forLocalPath({required String path}) => StellatuneApi
      .instance
      .api
      .crateApiPlayerTypesTrackRefForLocalPath(path: path);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<TrackRef> newInstance({
    required String sourceId,
    required String trackId,
    required String locator,
  }) => StellatuneApi.instance.api.crateApiPlayerTypesTrackRefNew(
    sourceId: sourceId,
    trackId: trackId,
    locator: locator,
  );

  Future<String> stableKey() => StellatuneApi.instance.api
      .crateApiPlayerTypesTrackRefStableKey(that: this);

  @override
  int get hashCode => sourceId.hashCode ^ trackId.hashCode ^ locator.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TrackRef &&
          runtimeType == other.runtimeType &&
          sourceId == other.sourceId &&
          trackId == other.trackId &&
          locator == other.locator;
}
